// Generated by rstantools.  Do not edit by hand.

/*
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model_blrm_exnex_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 818> locations_array__ =
  {" (found before start of program)",
  " (in 'blrm_exnex', line 752, column 2 to column 57)",
  " (in 'blrm_exnex', line 753, column 2 to column 50)",
  " (in 'blrm_exnex', line 756, column 2 to column 40)",
  " (in 'blrm_exnex', line 759, column 2 to column 66)",
  " (in 'blrm_exnex', line 760, column 2 to column 58)",
  " (in 'blrm_exnex', line 762, column 2 to column 27)",
  " (in 'blrm_exnex', line 763, column 2 to column 59)",
  " (in 'blrm_exnex', line 764, column 2 to column 45)",
  " (in 'blrm_exnex', line 767, column 2 to column 49)",
  " (in 'blrm_exnex', line 768, column 2 to column 46)",
  " (in 'blrm_exnex', line 769, column 2 to column 62)",
  " (in 'blrm_exnex', line 770, column 2 to column 55)",
  " (in 'blrm_exnex', line 898, column 2 to column 44)",
  " (in 'blrm_exnex', line 899, column 2 to column 44)",
  " (in 'blrm_exnex', line 900, column 2 to column 51)",
  " (in 'blrm_exnex', line 901, column 2 to column 48)",
  " (in 'blrm_exnex', line 902, column 2 to column 35)",
  " (in 'blrm_exnex', line 903, column 2 to column 32)",
  " (in 'blrm_exnex', line 904, column 2 to column 94)",
  " (in 'blrm_exnex', line 777, column 4 to column 36)",
  " (in 'blrm_exnex', line 778, column 4 to column 26)",
  " (in 'blrm_exnex', line 776, column 9 to line 779, column 3)",
  " (in 'blrm_exnex', line 774, column 4 to column 42)",
  " (in 'blrm_exnex', line 775, column 4 to column 38)",
  " (in 'blrm_exnex', line 773, column 27 to line 776, column 3)",
  " (in 'blrm_exnex', line 773, column 2 to line 779, column 3)",
  " (in 'blrm_exnex', line 783, column 4 to column 33)",
  " (in 'blrm_exnex', line 785, column 6 to line 788, column 42)",
  " (in 'blrm_exnex', line 784, column 28 to line 789, column 5)",
  " (in 'blrm_exnex', line 784, column 4 to line 789, column 5)",
  " (in 'blrm_exnex', line 791, column 6 to line 792, column 72)",
  " (in 'blrm_exnex', line 790, column 23 to line 793, column 5)",
  " (in 'blrm_exnex', line 790, column 4 to line 793, column 5)",
  " (in 'blrm_exnex', line 782, column 28 to line 794, column 3)",
  " (in 'blrm_exnex', line 782, column 2 to line 794, column 3)",
  " (in 'blrm_exnex', line 797, column 2 to line 798, column 82)",
  " (in 'blrm_exnex', line 799, column 2 to line 800, column 80)",
  " (in 'blrm_exnex', line 805, column 6 to column 41)",
  " (in 'blrm_exnex', line 804, column 28 to line 806, column 5)",
  " (in 'blrm_exnex', line 804, column 4 to line 806, column 5)",
  " (in 'blrm_exnex', line 803, column 32 to line 807, column 3)",
  " (in 'blrm_exnex', line 803, column 2 to line 807, column 3)",
  " (in 'blrm_exnex', line 907, column 4 to column 93)",
  " (in 'blrm_exnex', line 908, column 4 to column 48)",
  " (in 'blrm_exnex', line 906, column 26 to line 909, column 3)",
  " (in 'blrm_exnex', line 906, column 2 to line 909, column 3)",
  " (in 'blrm_exnex', line 913, column 4 to column 38)",
  " (in 'blrm_exnex', line 914, column 10 to column 20)",
  " (in 'blrm_exnex', line 914, column 4 to column 70)",
  " (in 'blrm_exnex', line 916, column 11 to column 23)",
  " (in 'blrm_exnex', line 916, column 4 to line 923, column 54)",
  " (in 'blrm_exnex', line 924, column 4 to column 40)",
  " (in 'blrm_exnex', line 925, column 11 to column 23)",
  " (in 'blrm_exnex', line 925, column 4 to column 61)",
  " (in 'blrm_exnex', line 926, column 4 to column 63)",
  " (in 'blrm_exnex', line 927, column 10 to column 18)",
  " (in 'blrm_exnex', line 927, column 4 to column 71)",
  " (in 'blrm_exnex', line 928, column 10 to column 19)",
  " (in 'blrm_exnex', line 928, column 4 to column 70)",
  " (in 'blrm_exnex', line 930, column 4 to column 58)",
  " (in 'blrm_exnex', line 934, column 6 to column 16)",
  " (in 'blrm_exnex', line 940, column 10 to column 35)",
  " (in 'blrm_exnex', line 939, column 15 to line 941, column 9)",
  " (in 'blrm_exnex', line 937, column 10 to column 84)",
  " (in 'blrm_exnex', line 938, column 10 to column 17)",
  " (in 'blrm_exnex', line 936, column 36 to line 939, column 9)",
  " (in 'blrm_exnex', line 936, column 8 to line 941, column 9)",
  " (in 'blrm_exnex', line 942, column 8 to line 943, column 81)",
  " (in 'blrm_exnex', line 935, column 30 to line 944, column 7)",
  " (in 'blrm_exnex', line 935, column 6 to line 944, column 7)",
  " (in 'blrm_exnex', line 933, column 4 to line 945, column 5)",
  " (in 'blrm_exnex', line 947, column 6 to column 16)",
  " (in 'blrm_exnex', line 953, column 10 to column 34)",
  " (in 'blrm_exnex', line 952, column 15 to line 954, column 9)",
  " (in 'blrm_exnex', line 950, column 10 to column 82)",
  " (in 'blrm_exnex', line 951, column 10 to column 17)",
  " (in 'blrm_exnex', line 949, column 37 to line 952, column 9)",
  " (in 'blrm_exnex', line 949, column 8 to line 954, column 9)",
  " (in 'blrm_exnex', line 955, column 8 to column 80)",
  " (in 'blrm_exnex', line 948, column 31 to line 956, column 7)",
  " (in 'blrm_exnex', line 948, column 6 to line 956, column 7)",
  " (in 'blrm_exnex', line 946, column 4 to line 957, column 5)",
  " (in 'blrm_exnex', line 912, column 28 to line 958, column 3)",
  " (in 'blrm_exnex', line 912, column 2 to line 958, column 3)",
  " (in 'blrm_exnex', line 826, column 13 to column 23)",
  " (in 'blrm_exnex', line 826, column 6 to column 33)",
  " (in 'blrm_exnex', line 830, column 8 to column 37)",
  " (in 'blrm_exnex', line 831, column 8 to column 42)",
  " (in 'blrm_exnex', line 832, column 14 to column 24)",
  " (in 'blrm_exnex', line 832, column 8 to column 74)",
  " (in 'blrm_exnex', line 852, column 10 to column 27)",
  " (in 'blrm_exnex', line 850, column 15 to line 853, column 9)",
  " (in 'blrm_exnex', line 835, column 17 to column 29)",
  " (in 'blrm_exnex', line 835, column 10 to line 846, column 60)",
  " (in 'blrm_exnex', line 849, column 10 to column 43)",
  " (in 'blrm_exnex', line 833, column 37 to line 850, column 9)",
  " (in 'blrm_exnex', line 833, column 8 to line 853, column 9)",
  " (in 'blrm_exnex', line 829, column 32 to line 854, column 7)",
  " (in 'blrm_exnex', line 829, column 6 to line 854, column 7)",
  " (in 'blrm_exnex', line 855, column 6 to column 29)",
  " (in 'blrm_exnex', line 825, column 11 to line 856, column 5)",
  " (in 'blrm_exnex', line 814, column 13 to column 20)",
  " (in 'blrm_exnex', line 814, column 6 to column 28)",
  " (in 'blrm_exnex', line 816, column 8 to column 37)",
  " (in 'blrm_exnex', line 817, column 8 to column 42)",
  " (in 'blrm_exnex', line 818, column 14 to column 24)",
  " (in 'blrm_exnex', line 818, column 8 to column 74)",
  " (in 'blrm_exnex', line 819, column 8 to line 820, column 68)",
  " (in 'blrm_exnex', line 815, column 32 to line 822, column 7)",
  " (in 'blrm_exnex', line 815, column 6 to line 822, column 7)",
  " (in 'blrm_exnex', line 824, column 6 to column 35)",
  " (in 'blrm_exnex', line 811, column 27 to line 825, column 5)",
  " (in 'blrm_exnex', line 811, column 4 to line 856, column 5)",
  " (in 'blrm_exnex', line 810, column 17 to line 857, column 3)",
  " (in 'blrm_exnex', line 810, column 2 to line 857, column 3)",
  " (in 'blrm_exnex', line 861, column 4 to column 130)",
  " (in 'blrm_exnex', line 864, column 6 to column 174)",
  " (in 'blrm_exnex', line 863, column 30 to line 865, column 5)",
  " (in 'blrm_exnex', line 863, column 4 to line 865, column 5)",
  " (in 'blrm_exnex', line 866, column 4 to column 70)",
  " (in 'blrm_exnex', line 860, column 26 to line 867, column 3)",
  " (in 'blrm_exnex', line 860, column 2 to line 867, column 3)",
  " (in 'blrm_exnex', line 869, column 2 to column 112)",
  " (in 'blrm_exnex', line 871, column 4 to column 160)",
  " (in 'blrm_exnex', line 870, column 28 to line 872, column 3)",
  " (in 'blrm_exnex', line 870, column 2 to line 872, column 3)",
  " (in 'blrm_exnex', line 875, column 4 to column 60)",
  " (in 'blrm_exnex', line 874, column 21 to line 876, column 3)",
  " (in 'blrm_exnex', line 874, column 2 to line 876, column 3)",
  " (in 'blrm_exnex', line 882, column 6 to column 40)",
  " (in 'blrm_exnex', line 881, column 28 to line 883, column 5)",
  " (in 'blrm_exnex', line 881, column 4 to line 883, column 5)",
  " (in 'blrm_exnex', line 885, column 4 to column 30)",
  " (in 'blrm_exnex', line 880, column 28 to line 886, column 3)",
  " (in 'blrm_exnex', line 880, column 2 to line 886, column 3)",
  " (in 'blrm_exnex', line 892, column 6 to column 140)",
  " (in 'blrm_exnex', line 890, column 28 to line 893, column 5)",
  " (in 'blrm_exnex', line 890, column 4 to line 893, column 5)",
  " (in 'blrm_exnex', line 894, column 4 to column 122)",
  " (in 'blrm_exnex', line 889, column 45 to line 895, column 3)",
  " (in 'blrm_exnex', line 889, column 2 to line 895, column 3)",
  " (in 'blrm_exnex', line 408, column 2 to column 23)",
  " (in 'blrm_exnex', line 409, column 8 to column 15)",
  " (in 'blrm_exnex', line 409, column 2 to column 32)",
  " (in 'blrm_exnex', line 410, column 8 to column 15)",
  " (in 'blrm_exnex', line 410, column 2 to column 33)",
  " (in 'blrm_exnex', line 413, column 2 to column 24)",
  " (in 'blrm_exnex', line 416, column 8 to column 16)",
  " (in 'blrm_exnex', line 416, column 25 to column 32)",
  " (in 'blrm_exnex', line 416, column 2 to column 44)",
  " (in 'blrm_exnex', line 419, column 2 to column 25)",
  " (in 'blrm_exnex', line 420, column 9 to column 16)",
  " (in 'blrm_exnex', line 420, column 18 to column 27)",
  " (in 'blrm_exnex', line 420, column 2 to column 37)",
  " (in 'blrm_exnex', line 425, column 8 to column 15)",
  " (in 'blrm_exnex', line 425, column 2 to column 36)",
  " (in 'blrm_exnex', line 428, column 8 to column 15)",
  " (in 'blrm_exnex', line 428, column 2 to column 38)",
  " (in 'blrm_exnex', line 431, column 2 to column 26)",
  " (in 'blrm_exnex', line 434, column 2 to column 26)",
  " (in 'blrm_exnex', line 437, column 8 to column 18)",
  " (in 'blrm_exnex', line 437, column 2 to column 69)",
  " (in 'blrm_exnex', line 440, column 8 to column 16)",
  " (in 'blrm_exnex', line 440, column 2 to column 60)",
  " (in 'blrm_exnex', line 441, column 8 to column 17)",
  " (in 'blrm_exnex', line 441, column 2 to column 62)",
  " (in 'blrm_exnex', line 448, column 30 to column 40)",
  " (in 'blrm_exnex', line 448, column 42 to column 50)",
  " (in 'blrm_exnex', line 448, column 2 to column 71)",
  " (in 'blrm_exnex', line 449, column 30 to column 40)",
  " (in 'blrm_exnex', line 449, column 42 to column 51)",
  " (in 'blrm_exnex', line 449, column 2 to column 73)",
  " (in 'blrm_exnex', line 452, column 8 to column 16)",
  " (in 'blrm_exnex', line 452, column 2 to column 42)",
  " (in 'blrm_exnex', line 453, column 8 to column 16)",
  " (in 'blrm_exnex', line 453, column 25 to column 53)",
  " (in 'blrm_exnex', line 453, column 2 to column 74)",
  " (in 'blrm_exnex', line 454, column 8 to column 16)",
  " (in 'blrm_exnex', line 454, column 17 to column 45)",
  " (in 'blrm_exnex', line 454, column 2 to column 76)",
  " (in 'blrm_exnex', line 455, column 8 to column 16)",
  " (in 'blrm_exnex', line 455, column 17 to column 45)",
  " (in 'blrm_exnex', line 455, column 2 to column 83)",
  " (in 'blrm_exnex', line 456, column 8 to column 18)",
  " (in 'blrm_exnex', line 456, column 20 to column 28)",
  " (in 'blrm_exnex', line 456, column 2 to column 55)",
  " (in 'blrm_exnex', line 457, column 8 to column 18)",
  " (in 'blrm_exnex', line 457, column 20 to column 28)",
  " (in 'blrm_exnex', line 457, column 37 to column 79)",
  " (in 'blrm_exnex', line 457, column 2 to column 101)",
  " (in 'blrm_exnex', line 458, column 8 to column 18)",
  " (in 'blrm_exnex', line 458, column 20 to column 28)",
  " (in 'blrm_exnex', line 458, column 30 to column 72)",
  " (in 'blrm_exnex', line 458, column 2 to column 104)",
  " (in 'blrm_exnex', line 459, column 8 to column 18)",
  " (in 'blrm_exnex', line 459, column 20 to column 28)",
  " (in 'blrm_exnex', line 459, column 30 to column 72)",
  " (in 'blrm_exnex', line 459, column 2 to column 111)",
  " (in 'blrm_exnex', line 460, column 8 to column 16)",
  " (in 'blrm_exnex', line 460, column 2 to column 55)",
  " (in 'blrm_exnex', line 461, column 2 to column 27)",
  " (in 'blrm_exnex', line 462, column 9 to column 29)",
  " (in 'blrm_exnex', line 462, column 2 to column 51)",
  " (in 'blrm_exnex', line 463, column 8 to column 28)",
  " (in 'blrm_exnex', line 463, column 37 to column 46)",
  " (in 'blrm_exnex', line 463, column 2 to column 68)",
  " (in 'blrm_exnex', line 464, column 8 to column 28)",
  " (in 'blrm_exnex', line 464, column 37 to column 46)",
  " (in 'blrm_exnex', line 464, column 47 to column 56)",
  " (in 'blrm_exnex', line 464, column 2 to column 82)",
  " (in 'blrm_exnex', line 465, column 8 to column 18)",
  " (in 'blrm_exnex', line 465, column 2 to column 46)",
  " (in 'blrm_exnex', line 466, column 8 to column 18)",
  " (in 'blrm_exnex', line 466, column 27 to column 57)",
  " (in 'blrm_exnex', line 466, column 2 to column 80)",
  " (in 'blrm_exnex', line 467, column 8 to column 18)",
  " (in 'blrm_exnex', line 467, column 20 to column 50)",
  " (in 'blrm_exnex', line 467, column 59 to column 68)",
  " (in 'blrm_exnex', line 467, column 2 to column 91)",
  " (in 'blrm_exnex', line 468, column 8 to column 18)",
  " (in 'blrm_exnex', line 468, column 20 to column 50)",
  " (in 'blrm_exnex', line 468, column 59 to column 68)",
  " (in 'blrm_exnex', line 468, column 70 to column 79)",
  " (in 'blrm_exnex', line 468, column 2 to column 106)",
  " (in 'blrm_exnex', line 470, column 2 to column 40)",
  " (in 'blrm_exnex', line 473, column 8 to column 16)",
  " (in 'blrm_exnex', line 473, column 2 to column 43)",
  " (in 'blrm_exnex', line 474, column 8 to column 16)",
  " (in 'blrm_exnex', line 474, column 25 to column 54)",
  " (in 'blrm_exnex', line 474, column 2 to column 76)",
  " (in 'blrm_exnex', line 475, column 8 to column 16)",
  " (in 'blrm_exnex', line 475, column 17 to column 46)",
  " (in 'blrm_exnex', line 475, column 2 to column 78)",
  " (in 'blrm_exnex', line 476, column 8 to column 16)",
  " (in 'blrm_exnex', line 476, column 17 to column 46)",
  " (in 'blrm_exnex', line 476, column 2 to column 85)",
  " (in 'blrm_exnex', line 477, column 2 to column 28)",
  " (in 'blrm_exnex', line 478, column 9 to column 30)",
  " (in 'blrm_exnex', line 478, column 2 to column 53)",
  " (in 'blrm_exnex', line 479, column 8 to column 29)",
  " (in 'blrm_exnex', line 479, column 38 to column 47)",
  " (in 'blrm_exnex', line 479, column 2 to column 70)",
  " (in 'blrm_exnex', line 480, column 8 to column 29)",
  " (in 'blrm_exnex', line 480, column 38 to column 47)",
  " (in 'blrm_exnex', line 480, column 48 to column 57)",
  " (in 'blrm_exnex', line 480, column 2 to column 84)",
  " (in 'blrm_exnex', line 486, column 2 to column 39)",
  " (in 'blrm_exnex', line 489, column 2 to column 33)",
  " (in 'blrm_exnex', line 492, column 8 to column 15)",
  " (in 'blrm_exnex', line 492, column 2 to column 32)",
  " (in 'blrm_exnex', line 493, column 8 to column 16)",
  " (in 'blrm_exnex', line 493, column 18 to column 25)",
  " (in 'blrm_exnex', line 493, column 2 to column 60)",
  " (in 'blrm_exnex', line 494, column 2 to column 73)",
  " (in 'blrm_exnex', line 495, column 2 to column 76)",
  " (in 'blrm_exnex', line 496, column 2 to column 62)",
  " (in 'blrm_exnex', line 497, column 2 to column 56)",
  " (in 'blrm_exnex', line 498, column 8 to column 16)",
  " (in 'blrm_exnex', line 498, column 17 to column 45)",
  " (in 'blrm_exnex', line 498, column 2 to column 159)",
  " (in 'blrm_exnex', line 499, column 8 to column 16)",
  " (in 'blrm_exnex', line 499, column 17 to column 46)",
  " (in 'blrm_exnex', line 499, column 2 to column 162)",
  " (in 'blrm_exnex', line 500, column 8 to column 28)",
  " (in 'blrm_exnex', line 500, column 37 to column 46)",
  " (in 'blrm_exnex', line 500, column 48 to column 57)",
  " (in 'blrm_exnex', line 500, column 2 to column 158)",
  " (in 'blrm_exnex', line 501, column 8 to column 29)",
  " (in 'blrm_exnex', line 501, column 38 to column 47)",
  " (in 'blrm_exnex', line 501, column 49 to column 58)",
  " (in 'blrm_exnex', line 501, column 2 to column 161)",
  " (in 'blrm_exnex', line 502, column 8 to column 18)",
  " (in 'blrm_exnex', line 502, column 20 to column 28)",
  " (in 'blrm_exnex', line 502, column 30 to column 72)",
  " (in 'blrm_exnex', line 502, column 2 to column 213)",
  " (in 'blrm_exnex', line 503, column 8 to column 18)",
  " (in 'blrm_exnex', line 503, column 20 to column 50)",
  " (in 'blrm_exnex', line 503, column 59 to column 68)",
  " (in 'blrm_exnex', line 503, column 70 to column 79)",
  " (in 'blrm_exnex', line 503, column 2 to column 203)",
  " (in 'blrm_exnex', line 506, column 8 to column 18)",
  " (in 'blrm_exnex', line 506, column 20 to column 28)",
  " (in 'blrm_exnex', line 506, column 2 to column 106)",
  " (in 'blrm_exnex', line 507, column 8 to column 18)",
  " (in 'blrm_exnex', line 507, column 27 to column 36)",
  " (in 'blrm_exnex', line 507, column 2 to column 112)",
  " (in 'blrm_exnex', line 512, column 6 to column 92)",
  " (in 'blrm_exnex', line 511, column 46 to line 513, column 5)",
  " (in 'blrm_exnex', line 511, column 4 to line 513, column 5)",
  " (in 'blrm_exnex', line 515, column 6 to column 94)",
  " (in 'blrm_exnex', line 514, column 47 to line 516, column 5)",
  " (in 'blrm_exnex', line 514, column 4 to line 516, column 5)",
  " (in 'blrm_exnex', line 519, column 8 to column 100)",
  " (in 'blrm_exnex', line 518, column 30 to line 520, column 7)",
  " (in 'blrm_exnex', line 518, column 6 to line 520, column 7)",
  " (in 'blrm_exnex', line 517, column 60 to line 521, column 5)",
  " (in 'blrm_exnex', line 517, column 4 to line 521, column 5)",
  " (in 'blrm_exnex', line 510, column 24 to line 522, column 3)",
  " (in 'blrm_exnex', line 510, column 2 to line 522, column 3)",
  " (in 'blrm_exnex', line 525, column 4 to column 88)",
  " (in 'blrm_exnex', line 524, column 36 to line 526, column 3)",
  " (in 'blrm_exnex', line 524, column 2 to line 526, column 3)",
  " (in 'blrm_exnex', line 528, column 4 to column 90)",
  " (in 'blrm_exnex', line 527, column 37 to line 529, column 3)",
  " (in 'blrm_exnex', line 527, column 2 to line 529, column 3)",
  " (in 'blrm_exnex', line 532, column 6 to column 96)",
  " (in 'blrm_exnex', line 531, column 61 to line 533, column 5)",
  " (in 'blrm_exnex', line 531, column 4 to line 533, column 5)",
  " (in 'blrm_exnex', line 530, column 26 to line 534, column 3)",
  " (in 'blrm_exnex', line 530, column 2 to line 534, column 3)",
  " (in 'blrm_exnex', line 538, column 8 to column 95)",
  " (in 'blrm_exnex', line 537, column 45 to line 539, column 7)",
  " (in 'blrm_exnex', line 537, column 6 to line 539, column 7)",
  " (in 'blrm_exnex', line 536, column 26 to line 540, column 5)",
  " (in 'blrm_exnex', line 536, column 4 to line 540, column 5)",
  " (in 'blrm_exnex', line 542, column 6 to column 91)",
  " (in 'blrm_exnex', line 541, column 42 to line 543, column 5)",
  " (in 'blrm_exnex', line 541, column 4 to line 543, column 5)",
  " (in 'blrm_exnex', line 535, column 26 to line 544, column 3)",
  " (in 'blrm_exnex', line 535, column 2 to line 544, column 3)",
  " (in 'blrm_exnex', line 545, column 8 to column 22)",
  " (in 'blrm_exnex', line 545, column 24 to column 76)",
  " (in 'blrm_exnex', line 545, column 2 to line 546, column 103)",
  " (in 'blrm_exnex', line 547, column 8 to column 23)",
  " (in 'blrm_exnex', line 547, column 25 to column 77)",
  " (in 'blrm_exnex', line 547, column 2 to line 548, column 102)",
  " (in 'blrm_exnex', line 549, column 8 to column 20)",
  " (in 'blrm_exnex', line 549, column 22 to column 30)",
  " (in 'blrm_exnex', line 549, column 2 to column 67)",
  " (in 'blrm_exnex', line 550, column 8 to column 20)",
  " (in 'blrm_exnex', line 550, column 22 to column 31)",
  " (in 'blrm_exnex', line 550, column 2 to column 67)",
  " (in 'blrm_exnex', line 552, column 8 to column 18)",
  " (in 'blrm_exnex', line 552, column 2 to line 554, column 81)",
  " (in 'blrm_exnex', line 556, column 8 to column 18)",
  " (in 'blrm_exnex', line 556, column 2 to column 76)",
  " (in 'blrm_exnex', line 558, column 8 to column 18)",
  " (in 'blrm_exnex', line 558, column 20 to column 38)",
  " (in 'blrm_exnex', line 558, column 2 to line 560, column 88)",
  " (in 'blrm_exnex', line 561, column 8 to column 18)",
  " (in 'blrm_exnex', line 561, column 36 to column 48)",
  " (in 'blrm_exnex', line 561, column 2 to column 65)",
  " (in 'blrm_exnex', line 562, column 9 to column 19)",
  " (in 'blrm_exnex', line 562, column 2 to column 70)",
  " (in 'blrm_exnex', line 566, column 4 to column 14)",
  " (in 'blrm_exnex', line 569, column 8 to column 32)",
  " (in 'blrm_exnex', line 570, column 8 to column 18)",
  " (in 'blrm_exnex', line 568, column 25 to line 571, column 7)",
  " (in 'blrm_exnex', line 568, column 6 to line 571, column 7)",
  " (in 'blrm_exnex', line 567, column 27 to line 572, column 5)",
  " (in 'blrm_exnex', line 567, column 4 to line 572, column 5)",
  " (in 'blrm_exnex', line 565, column 28 to line 573, column 3)",
  " (in 'blrm_exnex', line 565, column 2 to line 573, column 3)",
  " (in 'blrm_exnex', line 578, column 4 to column 38)",
  " (in 'blrm_exnex', line 579, column 10 to column 20)",
  " (in 'blrm_exnex', line 579, column 4 to column 70)",
  " (in 'blrm_exnex', line 581, column 6 to column 62)",
  " (in 'blrm_exnex', line 580, column 48 to line 582, column 5)",
  " (in 'blrm_exnex', line 580, column 4 to line 582, column 5)",
  " (in 'blrm_exnex', line 577, column 28 to line 583, column 3)",
  " (in 'blrm_exnex', line 577, column 2 to line 583, column 3)",
  " (in 'blrm_exnex', line 586, column 11 to column 18)",
  " (in 'blrm_exnex', line 586, column 4 to column 57)",
  " (in 'blrm_exnex', line 588, column 6 to column 73)",
  " (in 'blrm_exnex', line 587, column 76 to line 589, column 5)",
  " (in 'blrm_exnex', line 587, column 4 to line 589, column 5)",
  " (in 'blrm_exnex', line 585, column 26 to line 590, column 3)",
  " (in 'blrm_exnex', line 585, column 2 to line 590, column 3)",
  " (in 'blrm_exnex', line 593, column 11 to column 18)",
  " (in 'blrm_exnex', line 593, column 4 to column 56)",
  " (in 'blrm_exnex', line 595, column 6 to column 98)",
  " (in 'blrm_exnex', line 594, column 76 to line 596, column 5)",
  " (in 'blrm_exnex', line 594, column 4 to line 596, column 5)",
  " (in 'blrm_exnex', line 592, column 21 to line 597, column 3)",
  " (in 'blrm_exnex', line 592, column 2 to line 597, column 3)",
  " (in 'blrm_exnex', line 602, column 4 to column 24)",
  " (in 'blrm_exnex', line 603, column 4 to column 58)",
  " (in 'blrm_exnex', line 601, column 25 to line 604, column 3)",
  " (in 'blrm_exnex', line 601, column 2 to line 604, column 3)",
  " (in 'blrm_exnex', line 608, column 4 to column 38)",
  " (in 'blrm_exnex', line 609, column 10 to column 20)",
  " (in 'blrm_exnex', line 609, column 4 to column 70)",
  " (in 'blrm_exnex', line 610, column 4 to column 42)",
  " (in 'blrm_exnex', line 607, column 28 to line 611, column 3)",
  " (in 'blrm_exnex', line 607, column 2 to line 611, column 3)",
  " (in 'blrm_exnex', line 614, column 10 to column 17)",
  " (in 'blrm_exnex', line 614, column 4 to column 62)",
  " (in 'blrm_exnex', line 617, column 8 to line 618, column 63)",
  " (in 'blrm_exnex', line 619, column 8 to column 65)",
  " (in 'blrm_exnex', line 616, column 29 to line 620, column 7)",
  " (in 'blrm_exnex', line 616, column 6 to line 620, column 7)",
  " (in 'blrm_exnex', line 615, column 28 to line 621, column 5)",
  " (in 'blrm_exnex', line 615, column 4 to line 621, column 5)",
  " (in 'blrm_exnex', line 624, column 8 to column 59)",
  " (in 'blrm_exnex', line 623, column 34 to line 625, column 7)",
  " (in 'blrm_exnex', line 623, column 6 to line 625, column 7)",
  " (in 'blrm_exnex', line 622, column 27 to line 626, column 5)",
  " (in 'blrm_exnex', line 622, column 4 to line 626, column 5)",
  " (in 'blrm_exnex', line 613, column 2 to line 627, column 3)",
  " (in 'blrm_exnex', line 629, column 2 to column 42)",
  " (in 'blrm_exnex', line 630, column 2 to column 42)",
  " (in 'blrm_exnex', line 631, column 2 to line 632, column 38)",
  " (in 'blrm_exnex', line 633, column 2 to line 634, column 36)",
  " (in 'blrm_exnex', line 635, column 2 to line 636, column 40)",
  " (in 'blrm_exnex', line 638, column 2 to column 44)",
  " (in 'blrm_exnex', line 640, column 4 to column 69)",
  " (in 'blrm_exnex', line 639, column 28 to line 641, column 3)",
  " (in 'blrm_exnex', line 639, column 2 to line 641, column 3)",
  " (in 'blrm_exnex', line 643, column 2 to column 12)",
  " (in 'blrm_exnex', line 644, column 2 to column 40)",
  " (in 'blrm_exnex', line 646, column 4 to column 43)",
  " (in 'blrm_exnex', line 645, column 28 to line 647, column 3)",
  " (in 'blrm_exnex', line 645, column 2 to line 647, column 3)",
  " (in 'blrm_exnex', line 649, column 2 to column 49)",
  " (in 'blrm_exnex', line 655, column 4 to column 30)",
  " (in 'blrm_exnex', line 654, column 34 to line 656, column 3)",
  " (in 'blrm_exnex', line 654, column 9 to line 656, column 3)",
  " (in 'blrm_exnex', line 653, column 4 to column 24)",
  " (in 'blrm_exnex', line 652, column 34 to line 654, column 3)",
  " (in 'blrm_exnex', line 652, column 9 to line 656, column 3)",
  " (in 'blrm_exnex', line 651, column 4 to column 19)",
  " (in 'blrm_exnex', line 650, column 27 to line 652, column 3)",
  " (in 'blrm_exnex', line 650, column 2 to line 656, column 3)",
  " (in 'blrm_exnex', line 659, column 4 to column 64)",
  " (in 'blrm_exnex', line 658, column 16 to line 660, column 3)",
  " (in 'blrm_exnex', line 658, column 2 to line 660, column 3)",
  " (in 'blrm_exnex', line 663, column 4 to column 54)",
  " (in 'blrm_exnex', line 662, column 28 to line 664, column 3)",
  " (in 'blrm_exnex', line 662, column 2 to line 664, column 3)",
  " (in 'blrm_exnex', line 670, column 10 to column 21)",
  " (in 'blrm_exnex', line 670, column 4 to column 78)",
  " (in 'blrm_exnex', line 671, column 10 to column 30)",
  " (in 'blrm_exnex', line 671, column 4 to column 44)",
  " (in 'blrm_exnex', line 674, column 6 to column 27)",
  " (in 'blrm_exnex', line 672, column 31 to line 675, column 5)",
  " (in 'blrm_exnex', line 672, column 4 to line 675, column 5)",
  " (in 'blrm_exnex', line 678, column 6 to column 16)",
  " (in 'blrm_exnex', line 686, column 10 to column 25)",
  " (in 'blrm_exnex', line 685, column 15 to line 687, column 9)",
  " (in 'blrm_exnex', line 683, column 10 to column 39)",
  " (in 'blrm_exnex', line 684, column 10 to column 17)",
  " (in 'blrm_exnex', line 682, column 36 to line 685, column 9)",
  " (in 'blrm_exnex', line 682, column 8 to line 687, column 9)",
  " (in 'blrm_exnex', line 679, column 30 to line 688, column 7)",
  " (in 'blrm_exnex', line 679, column 6 to line 688, column 7)",
  " (in 'blrm_exnex', line 677, column 4 to line 689, column 5)",
  " (in 'blrm_exnex', line 691, column 6 to column 16)",
  " (in 'blrm_exnex', line 699, column 10 to column 36)",
  " (in 'blrm_exnex', line 698, column 15 to line 700, column 9)",
  " (in 'blrm_exnex', line 696, column 10 to column 67)",
  " (in 'blrm_exnex', line 697, column 10 to column 17)",
  " (in 'blrm_exnex', line 695, column 37 to line 698, column 9)",
  " (in 'blrm_exnex', line 695, column 8 to line 700, column 9)",
  " (in 'blrm_exnex', line 692, column 31 to line 701, column 7)",
  " (in 'blrm_exnex', line 692, column 6 to line 701, column 7)",
  " (in 'blrm_exnex', line 690, column 4 to line 702, column 5)",
  " (in 'blrm_exnex', line 709, column 10 to line 711, column 68)",
  " (in 'blrm_exnex', line 708, column 36 to line 712, column 9)",
  " (in 'blrm_exnex', line 708, column 8 to line 712, column 9)",
  " (in 'blrm_exnex', line 707, column 30 to line 713, column 7)",
  " (in 'blrm_exnex', line 707, column 6 to line 713, column 7)",
  " (in 'blrm_exnex', line 716, column 10 to line 718, column 69)",
  " (in 'blrm_exnex', line 715, column 37 to line 719, column 9)",
  " (in 'blrm_exnex', line 715, column 8 to line 719, column 9)",
  " (in 'blrm_exnex', line 714, column 31 to line 720, column 7)",
  " (in 'blrm_exnex', line 714, column 6 to line 720, column 7)",
  " (in 'blrm_exnex', line 723, column 6 to column 46)",
  " (in 'blrm_exnex', line 724, column 6 to column 68)",
  " (in 'blrm_exnex', line 704, column 30 to line 725, column 5)",
  " (in 'blrm_exnex', line 704, column 4 to line 725, column 5)",
  " (in 'blrm_exnex', line 669, column 30 to line 726, column 3)",
  " (in 'blrm_exnex', line 669, column 2 to line 726, column 3)",
  " (in 'blrm_exnex', line 731, column 4 to column 14)",
  " (in 'blrm_exnex', line 734, column 8 to column 64)",
  " (in 'blrm_exnex', line 735, column 8 to column 15)",
  " (in 'blrm_exnex', line 733, column 34 to line 736, column 7)",
  " (in 'blrm_exnex', line 733, column 6 to line 736, column 7)",
  " (in 'blrm_exnex', line 732, column 28 to line 737, column 5)",
  " (in 'blrm_exnex', line 732, column 4 to line 737, column 5)",
  " (in 'blrm_exnex', line 730, column 2 to line 738, column 3)",
  " (in 'blrm_exnex', line 740, column 4 to column 14)",
  " (in 'blrm_exnex', line 743, column 8 to column 62)",
  " (in 'blrm_exnex', line 744, column 8 to column 15)",
  " (in 'blrm_exnex', line 742, column 35 to line 745, column 7)",
  " (in 'blrm_exnex', line 742, column 6 to line 745, column 7)",
  " (in 'blrm_exnex', line 741, column 29 to line 746, column 5)",
  " (in 'blrm_exnex', line 741, column 4 to line 746, column 5)",
  " (in 'blrm_exnex', line 739, column 2 to line 747, column 3)",
  " (in 'blrm_exnex', line 752, column 8 to column 22)",
  " (in 'blrm_exnex', line 752, column 24 to column 32)",
  " (in 'blrm_exnex', line 753, column 8 to column 22)",
  " (in 'blrm_exnex', line 753, column 31 to column 40)",
  " (in 'blrm_exnex', line 756, column 8 to column 16)",
  " (in 'blrm_exnex', line 759, column 8 to column 18)",
  " (in 'blrm_exnex', line 759, column 20 to column 28)",
  " (in 'blrm_exnex', line 760, column 8 to column 16)",
  " (in 'blrm_exnex', line 762, column 9 to column 18)",
  " (in 'blrm_exnex', line 763, column 8 to column 18)",
  " (in 'blrm_exnex', line 763, column 36 to column 45)",
  " (in 'blrm_exnex', line 764, column 23 to column 32)",
  " (in 'blrm_exnex', line 767, column 8 to column 22)",
  " (in 'blrm_exnex', line 767, column 24 to column 32)",
  " (in 'blrm_exnex', line 768, column 8 to column 22)",
  " (in 'blrm_exnex', line 768, column 31 to column 40)",
  " (in 'blrm_exnex', line 769, column 8 to column 18)",
  " (in 'blrm_exnex', line 769, column 20 to column 28)",
  " (in 'blrm_exnex', line 770, column 8 to column 18)",
  " (in 'blrm_exnex', line 770, column 36 to column 45)",
  " (in 'blrm_exnex', line 898, column 9 to column 19)",
  " (in 'blrm_exnex', line 898, column 21 to column 29)",
  " (in 'blrm_exnex', line 899, column 9 to column 19)",
  " (in 'blrm_exnex', line 899, column 21 to column 30)",
  " (in 'blrm_exnex', line 900, column 8 to column 18)",
  " (in 'blrm_exnex', line 900, column 20 to column 28)",
  " (in 'blrm_exnex', line 901, column 8 to column 18)",
  " (in 'blrm_exnex', line 901, column 27 to column 36)",
  " (in 'blrm_exnex', line 902, column 9 to column 19)",
  " (in 'blrm_exnex', line 903, column 9 to column 17)",
  " (in 'blrm_exnex', line 904, column 9 to column 18)",
  " (in 'blrm_exnex', line 904, column 20 to column 29)",
  " (in 'blrm_exnex', line 17, column 10 to column 21)",
  " (in 'blrm_exnex', line 17, column 4 to column 30)",
  " (in 'blrm_exnex', line 18, column 4 to column 15)",
  " (in 'blrm_exnex', line 19, column 4 to column 15)",
  " (in 'blrm_exnex', line 21, column 6 to column 21)",
  " (in 'blrm_exnex', line 22, column 6 to column 21)",
  " (in 'blrm_exnex', line 20, column 27 to line 23, column 5)",
  " (in 'blrm_exnex', line 20, column 4 to line 23, column 5)",
  " (in 'blrm_exnex', line 24, column 4 to column 14)",
  " (in 'blrm_exnex', line 16, column 46 to line 25, column 3)",
  " (in 'blrm_exnex', line 29, column 4 to column 14)",
  " (in 'blrm_exnex', line 32, column 8 to column 18)",
  " (in 'blrm_exnex', line 31, column 32 to line 33, column 7)",
  " (in 'blrm_exnex', line 31, column 6 to line 33, column 7)",
  " (in 'blrm_exnex', line 30, column 37 to line 34, column 5)",
  " (in 'blrm_exnex', line 30, column 4 to line 34, column 5)",
  " (in 'blrm_exnex', line 35, column 4 to column 13)",
  " (in 'blrm_exnex', line 28, column 38 to line 36, column 3)",
  " (in 'blrm_exnex', line 40, column 4 to column 14)",
  " (in 'blrm_exnex', line 43, column 8 to column 18)",
  " (in 'blrm_exnex', line 42, column 32 to line 44, column 7)",
  " (in 'blrm_exnex', line 42, column 6 to line 44, column 7)",
  " (in 'blrm_exnex', line 41, column 37 to line 45, column 5)",
  " (in 'blrm_exnex', line 41, column 4 to line 45, column 5)",
  " (in 'blrm_exnex', line 46, column 4 to column 13)",
  " (in 'blrm_exnex', line 39, column 40 to line 47, column 3)",
  " (in 'blrm_exnex', line 52, column 10 to column 29)",
  " (in 'blrm_exnex', line 52, column 4 to column 39)",
  " (in 'blrm_exnex', line 53, column 4 to column 14)",
  " (in 'blrm_exnex', line 54, column 4 to column 15)",
  " (in 'blrm_exnex', line 59, column 8 to column 18)",
  " (in 'blrm_exnex', line 60, column 8 to column 19)",
  " (in 'blrm_exnex', line 58, column 13 to line 61, column 7)",
  " (in 'blrm_exnex', line 57, column 8 to column 28)",
  " (in 'blrm_exnex', line 56, column 32 to line 58, column 7)",
  " (in 'blrm_exnex', line 56, column 6 to line 61, column 7)",
  " (in 'blrm_exnex', line 55, column 37 to line 62, column 5)",
  " (in 'blrm_exnex', line 55, column 4 to line 62, column 5)",
  " (in 'blrm_exnex', line 63, column 4 to column 15)",
  " (in 'blrm_exnex', line 51, column 39 to line 64, column 3)",
  " (in 'blrm_exnex', line 68, column 4 to column 32)",
  " (in 'blrm_exnex', line 69, column 10 to column 11)",
  " (in 'blrm_exnex', line 69, column 4 to column 67)",
  " (in 'blrm_exnex', line 71, column 4 to column 26)",
  " (in 'blrm_exnex', line 67, column 44 to line 72, column 3)",
  " (in 'blrm_exnex', line 75, column 10 to column 16)",
  " (in 'blrm_exnex', line 75, column 4 to column 31)",
  " (in 'blrm_exnex', line 76, column 4 to column 26)",
  " (in 'blrm_exnex', line 78, column 6 to column 35)",
  " (in 'blrm_exnex', line 79, column 6 to column 33)",
  " (in 'blrm_exnex', line 77, column 26 to line 80, column 5)",
  " (in 'blrm_exnex', line 77, column 4 to line 80, column 5)",
  " (in 'blrm_exnex', line 81, column 4 to column 20)",
  " (in 'blrm_exnex', line 74, column 62 to line 82, column 3)",
  " (in 'blrm_exnex', line 86, column 6 to column 90)",
  " (in 'blrm_exnex', line 85, column 19 to line 87, column 5)",
  " (in 'blrm_exnex', line 85, column 4 to line 87, column 5)",
  " (in 'blrm_exnex', line 91, column 6 to column 51)",
  " (in 'blrm_exnex', line 90, column 11 to line 92, column 5)",
  " (in 'blrm_exnex', line 89, column 6 to column 15)",
  " (in 'blrm_exnex', line 88, column 20 to line 90, column 5)",
  " (in 'blrm_exnex', line 88, column 4 to line 92, column 5)",
  " (in 'blrm_exnex', line 84, column 39 to line 93, column 3)",
  " (in 'blrm_exnex', line 97, column 4 to column 43)",
  " (in 'blrm_exnex', line 96, column 41 to line 98, column 3)",
  " (in 'blrm_exnex', line 102, column 11 to column 30)",
  " (in 'blrm_exnex', line 102, column 4 to column 65)",
  " (in 'blrm_exnex', line 103, column 4 to column 49)",
  " (in 'blrm_exnex', line 101, column 39 to line 104, column 3)",
  " (in 'blrm_exnex', line 108, column 4 to column 28)",
  " (in 'blrm_exnex', line 109, column 10 to column 11)",
  " (in 'blrm_exnex', line 109, column 4 to column 21)",
  " (in 'blrm_exnex', line 111, column 6 to column 29)",
  " (in 'blrm_exnex', line 110, column 21 to line 112, column 5)",
  " (in 'blrm_exnex', line 110, column 4 to line 112, column 5)",
  " (in 'blrm_exnex', line 113, column 4 to column 15)",
  " (in 'blrm_exnex', line 107, column 42 to line 114, column 3)",
  " (in 'blrm_exnex', line 119, column 4 to column 22)",
  " (in 'blrm_exnex', line 120, column 10 to column 11)",
  " (in 'blrm_exnex', line 120, column 4 to column 28)",
  " (in 'blrm_exnex', line 121, column 4 to column 14)",
  " (in 'blrm_exnex', line 124, column 6 to column 67)",
  " (in 'blrm_exnex', line 125, column 6 to column 22)",
  " (in 'blrm_exnex', line 123, column 29 to line 126, column 5)",
  " (in 'blrm_exnex', line 123, column 4 to line 126, column 5)",
  " (in 'blrm_exnex', line 128, column 4 to column 22)",
  " (in 'blrm_exnex', line 118, column 58 to line 129, column 3)",
  " (in 'blrm_exnex', line 134, column 4 to column 14)",
  " (in 'blrm_exnex', line 135, column 4 to column 14)",
  " (in 'blrm_exnex', line 138, column 8 to column 26)",
  " (in 'blrm_exnex', line 137, column 27 to line 139, column 7)",
  " (in 'blrm_exnex', line 137, column 6 to line 139, column 7)",
  " (in 'blrm_exnex', line 136, column 38 to line 140, column 5)",
  " (in 'blrm_exnex', line 136, column 4 to line 140, column 5)",
  " (in 'blrm_exnex', line 141, column 4 to column 17)",
  " (in 'blrm_exnex', line 133, column 45 to line 142, column 3)",
  " (in 'blrm_exnex', line 146, column 10 to column 29)",
  " (in 'blrm_exnex', line 146, column 4 to column 42)",
  " (in 'blrm_exnex', line 148, column 6 to column 45)",
  " (in 'blrm_exnex', line 147, column 39 to line 149, column 5)",
  " (in 'blrm_exnex', line 147, column 4 to line 149, column 5)",
  " (in 'blrm_exnex', line 150, column 4 to column 18)",
  " (in 'blrm_exnex', line 145, column 63 to line 151, column 3)",
  " (in 'blrm_exnex', line 155, column 10 to column 32)",
  " (in 'blrm_exnex', line 155, column 4 to column 42)",
  " (in 'blrm_exnex', line 156, column 4 to column 11)",
  " (in 'blrm_exnex', line 157, column 4 to column 11)",
  " (in 'blrm_exnex', line 160, column 8 to column 20)",
  " (in 'blrm_exnex', line 161, column 8 to column 20)",
  " (in 'blrm_exnex', line 159, column 27 to line 162, column 7)",
  " (in 'blrm_exnex', line 159, column 6 to line 162, column 7)",
  " (in 'blrm_exnex', line 158, column 38 to line 163, column 5)",
  " (in 'blrm_exnex', line 158, column 4 to line 163, column 5)",
  " (in 'blrm_exnex', line 164, column 4 to column 15)",
  " (in 'blrm_exnex', line 154, column 53 to line 165, column 3)",
  " (in 'blrm_exnex', line 169, column 4 to column 17)",
  " (in 'blrm_exnex', line 170, column 25 to column 79)",
  " (in 'blrm_exnex', line 170, column 4 to column 79)",
  " (in 'blrm_exnex', line 171, column 4 to column 23)",
  " (in 'blrm_exnex', line 173, column 6 to column 40)",
  " (in 'blrm_exnex', line 172, column 28 to line 174, column 5)",
  " (in 'blrm_exnex', line 172, column 4 to line 174, column 5)",
  " (in 'blrm_exnex', line 175, column 4 to column 20)",
  " (in 'blrm_exnex', line 168, column 32 to line 176, column 3)",
  " (in 'blrm_exnex', line 179, column 11 to column 13)",
  " (in 'blrm_exnex', line 179, column 4 to column 22)",
  " (in 'blrm_exnex', line 180, column 21 to column 32)",
  " (in 'blrm_exnex', line 180, column 4 to column 32)",
  " (in 'blrm_exnex', line 182, column 6 to column 61)",
  " (in 'blrm_exnex', line 181, column 19 to line 183, column 5)",
  " (in 'blrm_exnex', line 181, column 4 to line 183, column 5)",
  " (in 'blrm_exnex', line 184, column 4 to column 40)",
  " (in 'blrm_exnex', line 178, column 86 to line 185, column 3)",
  " (in 'blrm_exnex', line 195, column 6 to column 47)",
  " (in 'blrm_exnex', line 194, column 26 to line 196, column 5)",
  " (in 'blrm_exnex', line 194, column 11 to line 196, column 5)",
  " (in 'blrm_exnex', line 192, column 13 to column 22)",
  " (in 'blrm_exnex', line 192, column 6 to column 43)",
  " (in 'blrm_exnex', line 193, column 6 to column 66)",
  " (in 'blrm_exnex', line 191, column 26 to line 194, column 5)",
  " (in 'blrm_exnex', line 191, column 11 to line 196, column 5)",
  " (in 'blrm_exnex', line 190, column 6 to column 34)",
  " (in 'blrm_exnex', line 187, column 19 to line 191, column 5)",
  " (in 'blrm_exnex', line 187, column 4 to line 196, column 5)",
  " (in 'blrm_exnex', line 197, column 4 to column 44)",
  " (in 'blrm_exnex', line 186, column 104 to line 198, column 3)",
  " (in 'blrm_exnex', line 207, column 6 to column 37)",
  " (in 'blrm_exnex', line 206, column 26 to line 208, column 5)",
  " (in 'blrm_exnex', line 206, column 11 to line 208, column 5)",
  " (in 'blrm_exnex', line 205, column 6 to column 40)",
  " (in 'blrm_exnex', line 204, column 26 to line 206, column 5)",
  " (in 'blrm_exnex', line 204, column 11 to line 208, column 5)",
  " (in 'blrm_exnex', line 203, column 6 to column 34)",
  " (in 'blrm_exnex', line 200, column 19 to line 204, column 5)",
  " (in 'blrm_exnex', line 200, column 4 to line 208, column 5)",
  " (in 'blrm_exnex', line 209, column 4 to column 44)",
  " (in 'blrm_exnex', line 199, column 58 to line 210, column 3)",
  " (in 'blrm_exnex', line 214, column 4 to column 75)",
  " (in 'blrm_exnex', line 213, column 50 to line 215, column 3)",
  " (in 'blrm_exnex', line 223, column 4 to column 33)",
  " (in 'blrm_exnex', line 224, column 4 to column 32)",
  " (in 'blrm_exnex', line 225, column 4 to column 34)",
  " (in 'blrm_exnex', line 226, column 11 to column 18)",
  " (in 'blrm_exnex', line 226, column 4 to column 23)",
  " (in 'blrm_exnex', line 229, column 6 to column 28)",
  " (in 'blrm_exnex', line 230, column 6 to column 27)",
  " (in 'blrm_exnex', line 238, column 12 to column 72)",
  " (in 'blrm_exnex', line 237, column 34 to line 239, column 11)",
  " (in 'blrm_exnex', line 237, column 10 to line 239, column 11)",
  " (in 'blrm_exnex', line 235, column 32 to line 240, column 9)",
  " (in 'blrm_exnex', line 235, column 8 to line 240, column 9)",
  " (in 'blrm_exnex', line 242, column 8 to column 49)",
  " (in 'blrm_exnex', line 234, column 13 to line 243, column 7)",
  " (in 'blrm_exnex', line 233, column 8 to column 20)",
  " (in 'blrm_exnex', line 231, column 23 to line 234, column 7)",
  " (in 'blrm_exnex', line 231, column 6 to line 243, column 7)",
  " (in 'blrm_exnex', line 247, column 8 to column 36)",
  " (in 'blrm_exnex', line 246, column 25 to line 248, column 7)",
  " (in 'blrm_exnex', line 246, column 6 to line 248, column 7)",
  " (in 'blrm_exnex', line 228, column 27 to line 249, column 5)",
  " (in 'blrm_exnex', line 228, column 4 to line 249, column 5)",
  " (in 'blrm_exnex', line 250, column 4 to column 14)",
  " (in 'blrm_exnex', line 222, column 74 to line 251, column 3)",
  " (in 'blrm_exnex', line 276, column 4 to column 33)",
  " (in 'blrm_exnex', line 277, column 10 to column 17)",
  " (in 'blrm_exnex', line 277, column 4 to column 29)",
  " (in 'blrm_exnex', line 278, column 10 to column 17)",
  " (in 'blrm_exnex', line 278, column 4 to column 29)",
  " (in 'blrm_exnex', line 280, column 6 to column 32)",
  " (in 'blrm_exnex', line 281, column 6 to column 32)",
  " (in 'blrm_exnex', line 279, column 27 to line 282, column 5)",
  " (in 'blrm_exnex', line 279, column 4 to line 282, column 5)",
  " (in 'blrm_exnex', line 283, column 4 to line 287, column 68)",
  " (in 'blrm_exnex', line 275, column 66 to line 288, column 3)",
  " (in 'blrm_exnex', line 293, column 4 to column 33)",
  " (in 'blrm_exnex', line 294, column 10 to column 17)",
  " (in 'blrm_exnex', line 294, column 4 to column 29)",
  " (in 'blrm_exnex', line 295, column 10 to column 17)",
  " (in 'blrm_exnex', line 295, column 4 to column 30)",
  " (in 'blrm_exnex', line 296, column 11 to column 18)",
  " (in 'blrm_exnex', line 296, column 4 to line 297, column 64)",
  " (in 'blrm_exnex', line 298, column 11 to column 18)",
  " (in 'blrm_exnex', line 298, column 4 to column 50)",
  " (in 'blrm_exnex', line 299, column 11 to column 18)",
  " (in 'blrm_exnex', line 299, column 4 to column 61)",
  " (in 'blrm_exnex', line 301, column 6 to column 32)",
  " (in 'blrm_exnex', line 302, column 6 to column 44)",
  " (in 'blrm_exnex', line 300, column 27 to line 303, column 5)",
  " (in 'blrm_exnex', line 300, column 4 to line 303, column 5)",
  " (in 'blrm_exnex', line 304, column 4 to line 305, column 56)",
  " (in 'blrm_exnex', line 292, column 72 to line 306, column 3)",
  " (in 'blrm_exnex', line 315, column 4 to column 42)",
  " (in 'blrm_exnex', line 316, column 4 to column 41)",
  " (in 'blrm_exnex', line 317, column 4 to column 41)",
  " (in 'blrm_exnex', line 318, column 11 to column 23)",
  " (in 'blrm_exnex', line 318, column 4 to column 34)",
  " (in 'blrm_exnex', line 321, column 6 to column 43)",
  " (in 'blrm_exnex', line 320, column 30 to line 322, column 5)",
  " (in 'blrm_exnex', line 320, column 4 to line 322, column 5)",
  " (in 'blrm_exnex', line 325, column 12 to column 20)",
  " (in 'blrm_exnex', line 325, column 6 to column 53)",
  " (in 'blrm_exnex', line 326, column 12 to column 21)",
  " (in 'blrm_exnex', line 326, column 6 to column 52)",
  " (in 'blrm_exnex', line 327, column 12 to column 20)",
  " (in 'blrm_exnex', line 327, column 6 to column 48)",
  " (in 'blrm_exnex', line 328, column 13 to column 22)",
  " (in 'blrm_exnex', line 328, column 6 to column 39)",
  " (in 'blrm_exnex', line 330, column 8 to column 76)",
  " (in 'blrm_exnex', line 329, column 30 to line 331, column 7)",
  " (in 'blrm_exnex', line 329, column 6 to line 331, column 7)",
  " (in 'blrm_exnex', line 333, column 8 to column 73)",
  " (in 'blrm_exnex', line 332, column 31 to line 334, column 7)",
  " (in 'blrm_exnex', line 332, column 6 to line 334, column 7)",
  " (in 'blrm_exnex', line 336, column 6 to column 109)",
  " (in 'blrm_exnex', line 324, column 32 to line 337, column 5)",
  " (in 'blrm_exnex', line 324, column 4 to line 337, column 5)",
  " (in 'blrm_exnex', line 339, column 4 to column 20)",
  " (in 'blrm_exnex', line 314, column 54 to line 340, column 3)",
  " (in 'blrm_exnex', line 350, column 4 to column 42)",
  " (in 'blrm_exnex', line 351, column 4 to column 41)",
  " (in 'blrm_exnex', line 352, column 4 to column 41)",
  " (in 'blrm_exnex', line 353, column 11 to column 23)",
  " (in 'blrm_exnex', line 353, column 4 to column 32)",
  " (in 'blrm_exnex', line 356, column 6 to column 43)",
  " (in 'blrm_exnex', line 355, column 30 to line 357, column 5)",
  " (in 'blrm_exnex', line 355, column 4 to line 357, column 5)",
  " (in 'blrm_exnex', line 360, column 12 to column 20)",
  " (in 'blrm_exnex', line 360, column 6 to column 53)",
  " (in 'blrm_exnex', line 361, column 12 to column 21)",
  " (in 'blrm_exnex', line 361, column 6 to column 52)",
  " (in 'blrm_exnex', line 362, column 12 to column 20)",
  " (in 'blrm_exnex', line 362, column 6 to column 48)",
  " (in 'blrm_exnex', line 363, column 13 to column 22)",
  " (in 'blrm_exnex', line 363, column 6 to column 39)",
  " (in 'blrm_exnex', line 365, column 8 to column 76)",
  " (in 'blrm_exnex', line 364, column 30 to line 366, column 7)",
  " (in 'blrm_exnex', line 364, column 6 to line 366, column 7)",
  " (in 'blrm_exnex', line 368, column 8 to column 73)",
  " (in 'blrm_exnex', line 367, column 31 to line 369, column 7)",
  " (in 'blrm_exnex', line 367, column 6 to line 369, column 7)",
  " (in 'blrm_exnex', line 371, column 6 to line 372, column 76)",
  " (in 'blrm_exnex', line 359, column 32 to line 373, column 5)",
  " (in 'blrm_exnex', line 359, column 4 to line 373, column 5)",
  " (in 'blrm_exnex', line 375, column 4 to column 18)",
  " (in 'blrm_exnex', line 349, column 55 to line 376, column 3)",
  " (in 'blrm_exnex', line 381, column 4 to column 21)",
  " (in 'blrm_exnex', line 382, column 4 to column 21)",
  " (in 'blrm_exnex', line 383, column 11 to column 13)",
  " (in 'blrm_exnex', line 383, column 15 to column 17)",
  " (in 'blrm_exnex', line 383, column 4 to column 47)",
  " (in 'blrm_exnex', line 384, column 10 to column 12)",
  " (in 'blrm_exnex', line 384, column 4 to column 45)",
  " (in 'blrm_exnex', line 385, column 4 to column 24)",
  " (in 'blrm_exnex', line 386, column 4 to column 23)",
  " (in 'blrm_exnex', line 387, column 18 to column 103)",
  " (in 'blrm_exnex', line 387, column 4 to column 103)",
  " (in 'blrm_exnex', line 389, column 6 to column 23)",
  " (in 'blrm_exnex', line 390, column 6 to column 23)",
  " (in 'blrm_exnex', line 392, column 24 to column 38)",
  " (in 'blrm_exnex', line 392, column 8 to column 38)",
  " (in 'blrm_exnex', line 393, column 24 to column 38)",
  " (in 'blrm_exnex', line 393, column 8 to column 38)",
  " (in 'blrm_exnex', line 391, column 21 to line 394, column 7)",
  " (in 'blrm_exnex', line 391, column 6 to line 394, column 7)",
  " (in 'blrm_exnex', line 396, column 8 to column 23)",
  " (in 'blrm_exnex', line 395, column 6 to line 396, column 23)",
  " (in 'blrm_exnex', line 388, column 19 to line 397, column 5)",
  " (in 'blrm_exnex', line 388, column 4 to line 397, column 5)",
  " (in 'blrm_exnex', line 398, column 27 to column 36)",
  " (in 'blrm_exnex', line 398, column 4 to column 36)",
  " (in 'blrm_exnex', line 399, column 58 to column 75)",
  " (in 'blrm_exnex', line 399, column 4 to column 75)",
  " (in 'blrm_exnex', line 400, column 63 to column 78)",
  " (in 'blrm_exnex', line 400, column 4 to column 78)",
  " (in 'blrm_exnex', line 401, column 4 to column 122)",
  " (in 'blrm_exnex', line 402, column 4 to column 13)",
  " (in 'blrm_exnex', line 380, column 44 to line 403, column 3)"};
std::vector<int>
make_slice_index(const std::vector<int>& S, std::ostream* pstream__);
int rle_elem_count(const std::vector<int>& set, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
int rle_elem_count_vector(const T0__& set_arg__, std::ostream* pstream__);
std::vector<int>
rle_int(const std::vector<int>& set, std::ostream* pstream__);
std::vector<int>
rle_elem_int(const std::vector<int>& set, std::ostream* pstream__);
std::vector<int>
decimal2base(const int& decimal, const int& digits, const int& base,
             std::ostream* pstream__);
int power_int(const int& number, const int& power, std::ostream* pstream__);
int cardinality_int(const std::vector<int>& elems, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
int cardinality_vector(const T0__& elems_arg__, std::ostream* pstream__);
std::vector<int>
seq_int(const int& start, const int& end, std::ostream* pstream__);
std::vector<int>
rep_each(const std::vector<int>& set, const std::vector<int>& each,
         std::ostream* pstream__);
int
count_elem(const std::vector<int>& test, const int& elem, std::ostream*
           pstream__);
std::vector<int>
count_elems(const std::vector<int>& test, const std::vector<int>& elems,
            std::ostream* pstream__);
std::vector<int>
which_elem(const std::vector<int>& test, const int& elem, std::ostream*
           pstream__);
int max_int(const std::vector<int>& test, std::ostream* pstream__);
template <bool propto__, typename T0__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T2__>, T3__,
  T4__>
mixmvnorm_lpdf(const T0__& y_arg__, const int& Nc, const T2__& w_arg__,
               const std::vector<Eigen::Matrix<T3__,-1,1>>& m,
               const std::vector<Eigen::Matrix<T4__,-1,-1>>& L, std::ostream*
               pstream__);
template <bool propto__, typename T0__, typename T3__, typename T4__,
          typename T5__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_stan_scalar<T4__>,
                              stan::is_stan_scalar<T5__>>* = nullptr>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>, T4__,
  T5__>
mixmv_tau_prior_lpdf(const T0__& tau_arg__, const int& dist, const int& Nc,
                     const T3__& w_arg__,
                     const std::vector<Eigen::Matrix<T4__,-1,1>>& m,
                     const std::vector<Eigen::Matrix<T5__,-1,-1>>& L,
                     std::ostream* pstream__);
template <bool propto__, typename T0__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>>* = nullptr>
stan::promote_args_t<T0__, T2__, T3__>
tau_prior_lpdf(const T0__& tau, const int& dist, const T2__& a, const T3__&
               b, std::ostream* pstream__);
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_stan_scalar<T1__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T1__>,-1,-1>
bvn_cholesky_lower(const T0__& tau_arg__, const T1__& rho, std::ostream*
                   pstream__);
template <typename T2__, typename T4__, typename T5__, typename T6__,
          stan::require_all_t<stan::is_stan_scalar<T2__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_stan_scalar<T5__>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T2__, stan::base_type_t<T4__>, T5__,
                stan::base_type_t<T6__>>,-1,1>
blrm_logit_fast(const std::vector<int>& obs_gidx, const std::vector<int>& n,
                const std::vector<Eigen::Matrix<T2__,-1,-1>>& X_comp,
                const std::vector<std::vector<int>>& finite_cov, const T4__&
                X_inter_arg__, const std::vector<Eigen::Matrix<T5__,-1,1>>&
                beta, const T6__& eta_arg__, std::ostream* pstream__);
template <bool propto__, typename T3__, typename T5__, typename T6__,
          typename T7__,
          stan::require_all_t<stan::is_stan_scalar<T3__>,
                              stan::is_eigen_matrix_dynamic<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_stan_scalar<T6__>,
                              stan::is_col_vector<T7__>,
                              stan::is_vt_not_complex<T7__>>* = nullptr>
stan::promote_args_t<T3__, stan::base_type_t<T5__>, T6__,
  stan::base_type_t<T7__>>
blrm_lpmf(const std::vector<int>& r, const std::vector<int>& obs_gidx,
          const std::vector<int>& n,
          const std::vector<Eigen::Matrix<T3__,-1,-1>>& X_comp,
          const std::vector<std::vector<int>>& finite_cov, const T5__&
          X_inter_arg__, const std::vector<Eigen::Matrix<T6__,-1,1>>& beta,
          const T7__& eta_arg__, std::ostream* pstream__);
template <typename T3__, typename T5__, typename T6__, typename T7__,
          stan::require_all_t<stan::is_stan_scalar<T3__>,
                              stan::is_eigen_matrix_dynamic<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_stan_scalar<T6__>,
                              stan::is_col_vector<T7__>,
                              stan::is_vt_not_complex<T7__>>* = nullptr>
stan::promote_args_t<T3__, stan::base_type_t<T5__>, T6__,
  stan::base_type_t<T7__>>
blrm_lupmf_comp(const std::vector<int>& r, const std::vector<int>& obs_gidx,
                const std::vector<int>& n,
                const std::vector<Eigen::Matrix<T3__,-1,-1>>& X_comp,
                const std::vector<std::vector<int>>& finite_cov, const T5__&
                X_inter_arg__, const std::vector<Eigen::Matrix<T6__,-1,1>>&
                beta, const T7__& eta_arg__, std::ostream* pstream__);
template <typename T5__, typename T7__, typename T8__, typename T10__,
          stan::require_all_t<stan::is_stan_scalar<T5__>,
                              stan::is_eigen_matrix_dynamic<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_stan_scalar<T8__>,
                              stan::is_stan_scalar<T10__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T5__, stan::base_type_t<T7__>, T8__,
                T10__>,-1,1>
blrm_mix_lpmf_comp(const int& g, const int& num_groups,
                   const std::vector<int>& obs_gidx, const std::vector<int>&
                   r, const std::vector<int>& n,
                   const std::vector<Eigen::Matrix<T5__,-1,-1>>& X_comp,
                   const std::vector<std::vector<int>>& finite_cov,
                   const T7__& X_inter_arg__,
                   const std::vector<std::vector<Eigen::Matrix<T8__,-1,1>>>&
                   beta, const std::vector<std::vector<int>>& mix_idx_beta,
                   const std::vector<Eigen::Matrix<T10__,-1,1>>& eta,
                   const std::vector<std::vector<int>>& mix_idx_eta,
                   std::ostream* pstream__);
template <typename T5__, typename T7__, typename T8__, typename T10__,
          stan::require_all_t<stan::is_stan_scalar<T5__>,
                              stan::is_eigen_matrix_dynamic<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_stan_scalar<T8__>,
                              stan::is_stan_scalar<T10__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<T5__, stan::base_type_t<T7__>, T8__,
                T10__>,-1,1>
blrm_mix_lupmf_comp(const int& g, const int& num_groups,
                    const std::vector<int>& obs_gidx, const std::vector<int>&
                    r, const std::vector<int>& n,
                    const std::vector<Eigen::Matrix<T5__,-1,-1>>& X_comp,
                    const std::vector<std::vector<int>>& finite_cov,
                    const T7__& X_inter_arg__,
                    const std::vector<std::vector<Eigen::Matrix<T8__,-1,1>>>&
                    beta, const std::vector<std::vector<int>>& mix_idx_beta,
                    const std::vector<Eigen::Matrix<T10__,-1,1>>& eta,
                    const std::vector<std::vector<int>>& mix_idx_eta,
                    std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
block_cholesky_decompose(const T0__& A_arg__, std::ostream* pstream__);
std::vector<int>
make_slice_index(const std::vector<int>& S, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 521;
    stan::math::validate_non_negative_index("Si", "size(S) + 1",
      (stan::math::size(S) + 1));
    std::vector<int> Si =
      std::vector<int>((stan::math::size(S) + 1),
        std::numeric_limits<int>::min());
    int cv = std::numeric_limits<int>::min();
    current_statement__ = 523;
    cv = 1;
    current_statement__ = 524;
    stan::model::assign(Si, cv, "assigning variable Si",
      stan::model::index_uni(1));
    current_statement__ = 528;
    for (int i = 1; i <= stan::math::size(S); ++i) {
      current_statement__ = 525;
      cv = (cv + stan::model::rvalue(S, "S", stan::model::index_uni(i)));
      current_statement__ = 526;
      stan::model::assign(Si, cv, "assigning variable Si",
        stan::model::index_uni((i + 1)));
    }
    current_statement__ = 529;
    return Si;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int rle_elem_count(const std::vector<int>& set, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int U = std::numeric_limits<int>::min();
    current_statement__ = 531;
    U = 1;
    current_statement__ = 536;
    for (int i = 2; i <= stan::math::num_elements(set); ++i) {
      current_statement__ = 534;
      if (stan::math::logical_neq(
            stan::model::rvalue(set, "set", stan::model::index_uni((i - 1))),
            stan::model::rvalue(set, "set", stan::model::index_uni(i)))) {
        current_statement__ = 532;
        U = (U + 1);
      }
    }
    current_statement__ = 537;
    return U;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
int rle_elem_count_vector(const T0__& set_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& set = stan::math::to_ref(set_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int U = std::numeric_limits<int>::min();
    current_statement__ = 539;
    U = 1;
    current_statement__ = 544;
    for (int i = 2; i <= stan::math::num_elements(set); ++i) {
      current_statement__ = 542;
      if (stan::math::logical_neq(
            stan::model::rvalue(set, "set", stan::model::index_uni((i - 1))),
            stan::model::rvalue(set, "set", stan::model::index_uni(i)))) {
        current_statement__ = 540;
        U = (U + 1);
      }
    }
    current_statement__ = 545;
    return U;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
std::vector<int>
rle_int(const std::vector<int>& set, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 547;
    stan::math::validate_non_negative_index("res", "rle_elem_count(set)",
      rle_elem_count(set, pstream__));
    std::vector<int> res =
      std::vector<int>(rle_elem_count(set, pstream__),
        std::numeric_limits<int>::min());
    int c = std::numeric_limits<int>::min();
    current_statement__ = 549;
    c = 1;
    current_statement__ = 550;
    stan::model::assign(res, 1, "assigning variable res",
      stan::model::index_uni(1));
    current_statement__ = 558;
    for (int i = 2; i <= stan::math::num_elements(set); ++i) {
      current_statement__ = 556;
      if (stan::math::logical_eq(
            stan::model::rvalue(set, "set", stan::model::index_uni((i - 1))),
            stan::model::rvalue(set, "set", stan::model::index_uni(i)))) {
        current_statement__ = 554;
        stan::model::assign(res,
          (stan::model::rvalue(res, "res", stan::model::index_uni(c)) + 1),
          "assigning variable res", stan::model::index_uni(c));
      } else {
        current_statement__ = 551;
        c = (c + 1);
        current_statement__ = 552;
        stan::model::assign(res, 1, "assigning variable res",
          stan::model::index_uni(c));
      }
    }
    current_statement__ = 559;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
std::vector<int>
rle_elem_int(const std::vector<int>& set, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int N = std::numeric_limits<int>::min();
    current_statement__ = 561;
    N = rle_elem_count(set, pstream__);
    current_statement__ = 562;
    stan::math::validate_non_negative_index("first_ind", "N", N);
    std::vector<int> first_ind =
      std::vector<int>(N, std::numeric_limits<int>::min());
    current_statement__ = 563;
    stan::model::assign(first_ind,
      stan::model::rvalue(
        make_slice_index(rle_int(set, pstream__), pstream__),
        "make_slice_index(rle_int(set))", stan::model::index_min_max(1, N)),
      "assigning variable first_ind");
    current_statement__ = 564;
    return stan::model::rvalue(set, "set",
             stan::model::index_multi(first_ind));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
std::vector<int>
decimal2base(const int& decimal, const int& digits, const int& base,
             std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 566;
    stan::math::validate_non_negative_index("base_rep", "digits", digits);
    std::vector<int> base_rep =
      std::vector<int>(digits, std::numeric_limits<int>::min());
    int current = std::numeric_limits<int>::min();
    current_statement__ = 568;
    current = decimal;
    current_statement__ = 572;
    for (int i = 1; i <= digits; ++i) {
      current_statement__ = 569;
      stan::model::assign(base_rep, stan::math::modulus(current, base),
        "assigning variable base_rep", stan::model::index_uni(i));
      current_statement__ = 570;
      current = (current / base);
    }
    current_statement__ = 573;
    return base_rep;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int power_int(const int& number, const int& power, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 577;
    if (stan::math::logical_lt(power, 0)) {
      current_statement__ = 575;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__,
        "Cannot raise an integer to a negative power and expect an integer result.");
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 582;
    if (stan::math::logical_eq(power, 0)) {
      current_statement__ = 580;
      return 1;
    } else {
      current_statement__ = 578;
      return (number * power_int(number, (power - 1), pstream__));
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int cardinality_int(const std::vector<int>& elems, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 584;
    return rle_elem_count(stan::math::sort_asc(elems), pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
int cardinality_vector(const T0__& elems_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& elems = stan::math::to_ref(elems_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 586;
    stan::math::validate_non_negative_index("sort_asc_elems",
      "num_elements(elems)", stan::math::num_elements(elems));
    Eigen::Matrix<local_scalar_t__,-1,1> sort_asc_elems =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::num_elements(
                                                       elems), DUMMY_VAR__);
    current_statement__ = 587;
    stan::model::assign(sort_asc_elems, stan::math::sort_asc(elems),
      "assigning variable sort_asc_elems");
    current_statement__ = 588;
    return rle_elem_count_vector(sort_asc_elems, pstream__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
std::vector<int>
seq_int(const int& start, const int& end, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int N = std::numeric_limits<int>::min();
    current_statement__ = 590;
    N = ((end - start) + 1);
    current_statement__ = 591;
    stan::math::validate_non_negative_index("seq", "N", N);
    std::vector<int> seq =
      std::vector<int>(N, std::numeric_limits<int>::min());
    current_statement__ = 595;
    for (int i = 1; i <= N; ++i) {
      current_statement__ = 593;
      stan::model::assign(seq, ((i + start) - 1), "assigning variable seq",
        stan::model::index_uni(i));
    }
    current_statement__ = 596;
    return seq;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
std::vector<int>
rep_each(const std::vector<int>& set, const std::vector<int>& each,
         std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int N = std::numeric_limits<int>::min();
    current_statement__ = 598;
    N = stan::math::sum(each);
    current_statement__ = 599;
    stan::math::validate_non_negative_index("replicated", "N", N);
    std::vector<int> replicated =
      std::vector<int>(N, std::numeric_limits<int>::min());
    int p = std::numeric_limits<int>::min();
    current_statement__ = 601;
    p = 1;
    current_statement__ = 605;
    for (int i = 1; i <= stan::math::size(set); ++i) {
      current_statement__ = 602;
      stan::model::assign(replicated,
        stan::math::rep_array(
          stan::model::rvalue(set, "set", stan::model::index_uni(i)),
          stan::model::rvalue(each, "each", stan::model::index_uni(i))),
        "assigning variable replicated",
        stan::model::index_min_max(p, ((p +
          stan::model::rvalue(each, "each", stan::model::index_uni(i))) - 1)));
      current_statement__ = 603;
      p = (p + stan::model::rvalue(each, "each", stan::model::index_uni(i)));
    }
    current_statement__ = 606;
    return replicated;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int
count_elem(const std::vector<int>& test, const int& elem, std::ostream*
           pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int count = std::numeric_limits<int>::min();
    current_statement__ = 609;
    count = 0;
    current_statement__ = 614;
    for (int i = 1; i <= stan::math::num_elements(test); ++i) {
      current_statement__ = 612;
      if (stan::math::logical_eq(
            stan::model::rvalue(test, "test", stan::model::index_uni(i)),
            elem)) {
        current_statement__ = 610;
        count = (count + 1);
      }
    }
    current_statement__ = 615;
    return count;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
std::vector<int>
count_elems(const std::vector<int>& test, const std::vector<int>& elems,
            std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 617;
    stan::math::validate_non_negative_index("counts", "num_elements(elems)",
      stan::math::num_elements(elems));
    std::vector<int> counts =
      std::vector<int>(stan::math::num_elements(elems),
        std::numeric_limits<int>::min());
    current_statement__ = 621;
    for (int i = 1; i <= stan::math::num_elements(elems); ++i) {
      current_statement__ = 619;
      stan::model::assign(counts,
        count_elem(test,
          stan::model::rvalue(elems, "elems", stan::model::index_uni(i)),
          pstream__), "assigning variable counts", stan::model::index_uni(i));
    }
    current_statement__ = 622;
    return counts;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
std::vector<int>
which_elem(const std::vector<int>& test, const int& elem, std::ostream*
           pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 624;
    stan::math::validate_non_negative_index("res", "count_elem(test, elem)",
      count_elem(test, elem, pstream__));
    std::vector<int> res =
      std::vector<int>(count_elem(test, elem, pstream__),
        std::numeric_limits<int>::min());
    int ci = std::numeric_limits<int>::min();
    current_statement__ = 627;
    ci = 1;
    current_statement__ = 633;
    for (int i = 1; i <= stan::math::num_elements(test); ++i) {
      current_statement__ = 631;
      if (stan::math::logical_eq(
            stan::model::rvalue(test, "test", stan::model::index_uni(i)),
            elem)) {
        current_statement__ = 628;
        stan::model::assign(res, i, "assigning variable res",
          stan::model::index_uni(ci));
        current_statement__ = 629;
        ci = (ci + 1);
      }
    }
    current_statement__ = 634;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
int max_int(const std::vector<int>& test, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int max_elem = std::numeric_limits<int>::min();
    current_statement__ = 638;
    if (stan::math::logical_eq(stan::math::size(test), 0)) {
      current_statement__ = 637;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__,
        "Test array must have length greater than 0.");
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 639;
    max_elem = stan::model::rvalue(test, "test", stan::model::index_uni(1));
    current_statement__ = 642;
    for (int i = 2; i <= stan::math::size(test); ++i) {
      current_statement__ = 640;
      max_elem = stan::math::max(max_elem,
                   stan::model::rvalue(test, "test",
                     stan::model::index_uni(i)));
    }
    current_statement__ = 643;
    return max_elem;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T0__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T2__>, T3__,
  T4__>
mixmvnorm_lpdf(const T0__& y_arg__, const int& Nc, const T2__& w_arg__,
               const std::vector<Eigen::Matrix<T3__,-1,1>>& m,
               const std::vector<Eigen::Matrix<T4__,-1,-1>>& L, std::ostream*
               pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T2__>, T3__, T4__>;
  int current_statement__ = 0;
  const auto& y = stan::math::to_ref(y_arg__);
  const auto& w = stan::math::to_ref(w_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 645;
    stan::math::validate_non_negative_index("lp_mix", "Nc", Nc);
    Eigen::Matrix<local_scalar_t__,-1,1> lp_mix =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(Nc, DUMMY_VAR__);
    current_statement__ = 648;
    if (stan::math::logical_eq(stan::math::rows(y), 0)) {
      current_statement__ = 647;
      return 0.0;
    }
    current_statement__ = 651;
    for (int i = 1; i <= Nc; ++i) {
      current_statement__ = 649;
      stan::model::assign(lp_mix,
        stan::math::multi_normal_cholesky_lpdf<false>(y,
          stan::model::rvalue(m, "m", stan::model::index_uni(i)),
          stan::model::rvalue(L, "L", stan::model::index_uni(i))),
        "assigning variable lp_mix", stan::model::index_uni(i));
    }
    current_statement__ = 652;
    return stan::math::log_sum_exp(
             stan::math::add(stan::math::log(w), lp_mix));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T0__, typename T3__, typename T4__,
          typename T5__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T3__>,
                              stan::is_vt_not_complex<T3__>,
                              stan::is_stan_scalar<T4__>,
                              stan::is_stan_scalar<T5__>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T3__>, T4__,
  T5__>
mixmv_tau_prior_lpdf(const T0__& tau_arg__, const int& dist, const int& Nc,
                     const T3__& w_arg__,
                     const std::vector<Eigen::Matrix<T4__,-1,1>>& m,
                     const std::vector<Eigen::Matrix<T5__,-1,-1>>& L,
                     std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             stan::base_type_t<T3__>, T4__, T5__>;
  int current_statement__ = 0;
  const auto& tau = stan::math::to_ref(tau_arg__);
  const auto& w = stan::math::to_ref(w_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 664;
    if (stan::math::logical_eq(dist, 0)) {
      current_statement__ = 662;
      return stan::math::std_normal_lpdf<false>(tau);
    } else {
      current_statement__ = 661;
      if (stan::math::logical_eq(dist, 1)) {
        current_statement__ = 657;
        stan::math::validate_non_negative_index("log_tau", "rows(tau)",
          stan::math::rows(tau));
        Eigen::Matrix<local_scalar_t__,-1,1> log_tau =
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::rows(tau),
            DUMMY_VAR__);
        current_statement__ = 658;
        stan::model::assign(log_tau, stan::math::log(tau),
          "assigning variable log_tau");
        current_statement__ = 659;
        return (mixmvnorm_lpdf<false>(log_tau, Nc, w, m, L, pstream__) -
               stan::math::sum(log_tau));
      } else {
        current_statement__ = 656;
        if (stan::math::logical_eq(dist, 2)) {
          current_statement__ = 654;
          return mixmvnorm_lpdf<false>(tau, Nc, w, m, L, pstream__);
        }
      }
    }
    current_statement__ = 665;
    std::stringstream errmsg_stream__;
    stan::math::stan_print(&errmsg_stream__, "Invalid distribution for tau.");
    throw std::domain_error(errmsg_stream__.str());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T0__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>>*>
stan::promote_args_t<T0__, T2__, T3__>
tau_prior_lpdf(const T0__& tau, const int& dist, const T2__& a, const T3__&
               b, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T2__, T3__>;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 675;
    if (stan::math::logical_eq(dist, 0)) {
      current_statement__ = 673;
      return stan::math::std_normal_lpdf<false>(tau);
    } else {
      current_statement__ = 672;
      if (stan::math::logical_eq(dist, 1)) {
        current_statement__ = 670;
        return stan::math::lognormal_lpdf<false>(tau, a, b);
      } else {
        current_statement__ = 669;
        if (stan::math::logical_eq(dist, 2)) {
          current_statement__ = 667;
          return stan::math::normal_lpdf<false>(tau, a, b);
        }
      }
    }
    current_statement__ = 676;
    std::stringstream errmsg_stream__;
    stan::math::stan_print(&errmsg_stream__, "Invalid distribution for tau.");
    throw std::domain_error(errmsg_stream__.str());
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_stan_scalar<T1__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>, T1__>,-1,-1>
bvn_cholesky_lower(const T0__& tau_arg__, const T1__& rho, std::ostream*
                   pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>,
                             T1__>;
  int current_statement__ = 0;
  const auto& tau = stan::math::to_ref(tau_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 678;
    return stan::math::to_matrix(
             std::vector<Eigen::Matrix<local_scalar_t__,1,-1>>{(Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                                  stan::model::rvalue(
                                                                    tau,
                                                                    "tau",
                                                                    stan::model::index_uni(
                                                                    1)),
                                                                 0.0).finished(),
               (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
                                                          (stan::model::rvalue(
                                                             tau, "tau",
                                                             stan::model::index_uni(
                                                               2))
                                                          * rho),
                                                          (stan::model::rvalue(
                                                             tau, "tau",
                                                             stan::model::index_uni(
                                                               2))
                                                          *
                                                          stan::math::sqrt(
                                                            (1.0 - (rho *
                                                            rho))))).finished()});
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T2__, typename T4__, typename T5__, typename T6__,
          stan::require_all_t<stan::is_stan_scalar<T2__>,
                              stan::is_eigen_matrix_dynamic<T4__>,
                              stan::is_vt_not_complex<T4__>,
                              stan::is_stan_scalar<T5__>,
                              stan::is_col_vector<T6__>,
                              stan::is_vt_not_complex<T6__>>*>
Eigen::Matrix<stan::promote_args_t<T2__, stan::base_type_t<T4__>, T5__,
                stan::base_type_t<T6__>>,-1,1>
blrm_logit_fast(const std::vector<int>& obs_gidx, const std::vector<int>& n,
                const std::vector<Eigen::Matrix<T2__,-1,-1>>& X_comp,
                const std::vector<std::vector<int>>& finite_cov, const T4__&
                X_inter_arg__, const std::vector<Eigen::Matrix<T5__,-1,1>>&
                beta, const T6__& eta_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T2__,
                             stan::base_type_t<T4__>, T5__,
                             stan::base_type_t<T6__>>;
  int current_statement__ = 0;
  const auto& X_inter = stan::math::to_ref(X_inter_arg__);
  const auto& eta = stan::math::to_ref(eta_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int num_obs = std::numeric_limits<int>::min();
    current_statement__ = 680;
    num_obs = stan::math::size(obs_gidx);
    int num_comp = std::numeric_limits<int>::min();
    current_statement__ = 681;
    num_comp = stan::math::size(X_comp);
    int num_inter = std::numeric_limits<int>::min();
    current_statement__ = 682;
    num_inter = stan::math::cols(X_inter);
    current_statement__ = 683;
    stan::math::validate_non_negative_index("mu", "num_obs", num_obs);
    Eigen::Matrix<local_scalar_t__,-1,1> mu =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_obs, DUMMY_VAR__);
    current_statement__ = 701;
    for (int i = 1; i <= num_obs; ++i) {
      int idx = std::numeric_limits<int>::min();
      current_statement__ = 685;
      idx = stan::model::rvalue(obs_gidx, "obs_gidx",
              stan::model::index_uni(i));
      local_scalar_t__ log_p0_nr = DUMMY_VAR__;
      current_statement__ = 686;
      log_p0_nr = 0.0;
      current_statement__ = 696;
      if (stan::math::logical_eq(
            stan::model::rvalue(n, "n", stan::model::index_uni(idx)), 0)) {
        current_statement__ = 694;
        stan::model::assign(mu, 0.0, "assigning variable mu",
          stan::model::index_uni(i));
      } else {
        current_statement__ = 691;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 689;
          if (stan::model::rvalue(finite_cov, "finite_cov",
                stan::model::index_uni(j), stan::model::index_uni(idx))) {
            current_statement__ = 687;
            log_p0_nr = (log_p0_nr +
              stan::math::log_inv_logit(
                stan::math::multiply(
                  stan::math::multiply(-1.0,
                    stan::model::rvalue(X_comp, "X_comp",
                      stan::model::index_uni(j), stan::model::index_uni(idx))),
                  stan::model::rvalue(beta, "beta", stan::model::index_uni(j)))));
          }
        }
        current_statement__ = 692;
        stan::model::assign(mu, (stan::math::log1m_exp(log_p0_nr) -
          log_p0_nr), "assigning variable mu", stan::model::index_uni(i));
      }
      current_statement__ = 699;
      if (stan::math::logical_gt(num_inter, 0)) {
        current_statement__ = 697;
        stan::model::assign(mu,
          (stan::model::rvalue(mu, "mu", stan::model::index_uni(i)) +
          stan::math::multiply(
            stan::model::rvalue(X_inter, "X_inter",
              stan::model::index_uni(idx)), eta)), "assigning variable mu",
          stan::model::index_uni(i));
      }
    }
    current_statement__ = 702;
    return mu;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T3__, typename T5__, typename T6__,
          typename T7__,
          stan::require_all_t<stan::is_stan_scalar<T3__>,
                              stan::is_eigen_matrix_dynamic<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_stan_scalar<T6__>,
                              stan::is_col_vector<T7__>,
                              stan::is_vt_not_complex<T7__>>*>
stan::promote_args_t<T3__, stan::base_type_t<T5__>, T6__,
  stan::base_type_t<T7__>>
blrm_lpmf(const std::vector<int>& r, const std::vector<int>& obs_gidx,
          const std::vector<int>& n,
          const std::vector<Eigen::Matrix<T3__,-1,-1>>& X_comp,
          const std::vector<std::vector<int>>& finite_cov, const T5__&
          X_inter_arg__, const std::vector<Eigen::Matrix<T6__,-1,1>>& beta,
          const T7__& eta_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T5__>, T6__,
                             stan::base_type_t<T7__>>;
  int current_statement__ = 0;
  const auto& X_inter = stan::math::to_ref(X_inter_arg__);
  const auto& eta = stan::math::to_ref(eta_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int num_obs = std::numeric_limits<int>::min();
    current_statement__ = 704;
    num_obs = stan::math::size(obs_gidx);
    current_statement__ = 705;
    stan::math::validate_non_negative_index("r_obs", "num_obs", num_obs);
    std::vector<int> r_obs =
      std::vector<int>(num_obs, std::numeric_limits<int>::min());
    current_statement__ = 707;
    stan::math::validate_non_negative_index("n_obs", "num_obs", num_obs);
    std::vector<int> n_obs =
      std::vector<int>(num_obs, std::numeric_limits<int>::min());
    current_statement__ = 712;
    for (int i = 1; i <= num_obs; ++i) {
      current_statement__ = 709;
      stan::model::assign(r_obs,
        stan::model::rvalue(r, "r",
          stan::model::index_uni(
            stan::model::rvalue(obs_gidx, "obs_gidx",
              stan::model::index_uni(i)))), "assigning variable r_obs",
        stan::model::index_uni(i));
      current_statement__ = 710;
      stan::model::assign(n_obs,
        stan::model::rvalue(n, "n",
          stan::model::index_uni(
            stan::model::rvalue(obs_gidx, "obs_gidx",
              stan::model::index_uni(i)))), "assigning variable n_obs",
        stan::model::index_uni(i));
    }
    current_statement__ = 713;
    return stan::math::binomial_logit_lpmf<false>(r_obs, n_obs,
             blrm_logit_fast(obs_gidx, n, X_comp, finite_cov, X_inter, beta,
               eta, pstream__));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T3__, typename T5__, typename T6__, typename T7__,
          stan::require_all_t<stan::is_stan_scalar<T3__>,
                              stan::is_eigen_matrix_dynamic<T5__>,
                              stan::is_vt_not_complex<T5__>,
                              stan::is_stan_scalar<T6__>,
                              stan::is_col_vector<T7__>,
                              stan::is_vt_not_complex<T7__>>*>
stan::promote_args_t<T3__, stan::base_type_t<T5__>, T6__,
  stan::base_type_t<T7__>>
blrm_lupmf_comp(const std::vector<int>& r, const std::vector<int>& obs_gidx,
                const std::vector<int>& n,
                const std::vector<Eigen::Matrix<T3__,-1,-1>>& X_comp,
                const std::vector<std::vector<int>>& finite_cov, const T5__&
                X_inter_arg__, const std::vector<Eigen::Matrix<T6__,-1,1>>&
                beta, const T7__& eta_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T3__,
                             stan::base_type_t<T5__>, T6__,
                             stan::base_type_t<T7__>>;
  int current_statement__ = 0;
  const auto& X_inter = stan::math::to_ref(X_inter_arg__);
  const auto& eta = stan::math::to_ref(eta_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int num_obs = std::numeric_limits<int>::min();
    current_statement__ = 715;
    num_obs = stan::math::size(obs_gidx);
    current_statement__ = 716;
    stan::math::validate_non_negative_index("r_obs", "num_obs", num_obs);
    std::vector<int> r_obs =
      std::vector<int>(num_obs, std::numeric_limits<int>::min());
    current_statement__ = 718;
    stan::math::validate_non_negative_index("nr_obs", "num_obs", num_obs);
    std::vector<int> nr_obs =
      std::vector<int>(num_obs, std::numeric_limits<int>::min());
    current_statement__ = 720;
    stan::math::validate_non_negative_index("theta", "num_obs", num_obs);
    Eigen::Matrix<local_scalar_t__,-1,1> theta =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_obs, DUMMY_VAR__);
    current_statement__ = 721;
    stan::model::assign(theta,
      blrm_logit_fast(obs_gidx, n, X_comp, finite_cov, X_inter, beta, eta,
        pstream__), "assigning variable theta");
    current_statement__ = 722;
    stan::math::validate_non_negative_index("log_pi", "num_obs", num_obs);
    Eigen::Matrix<local_scalar_t__,-1,1> log_pi =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_obs, DUMMY_VAR__);
    current_statement__ = 723;
    stan::model::assign(log_pi, stan::math::log_inv_logit(theta),
      "assigning variable log_pi");
    current_statement__ = 724;
    stan::math::validate_non_negative_index("log_inv_pi", "num_obs", num_obs);
    Eigen::Matrix<local_scalar_t__,-1,1> log_inv_pi =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_obs, DUMMY_VAR__);
    current_statement__ = 725;
    stan::model::assign(log_inv_pi,
      stan::math::log_inv_logit(stan::math::multiply(-1.0, theta)),
      "assigning variable log_inv_pi");
    current_statement__ = 729;
    for (int i = 1; i <= num_obs; ++i) {
      current_statement__ = 726;
      stan::model::assign(r_obs,
        stan::model::rvalue(r, "r",
          stan::model::index_uni(
            stan::model::rvalue(obs_gidx, "obs_gidx",
              stan::model::index_uni(i)))), "assigning variable r_obs",
        stan::model::index_uni(i));
      current_statement__ = 727;
      stan::model::assign(nr_obs,
        (stan::model::rvalue(n, "n",
           stan::model::index_uni(
             stan::model::rvalue(obs_gidx, "obs_gidx",
               stan::model::index_uni(i)))) -
        stan::model::rvalue(r_obs, "r_obs", stan::model::index_uni(i))),
        "assigning variable nr_obs", stan::model::index_uni(i));
    }
    current_statement__ = 730;
    return (stan::math::dot_product(stan::math::to_vector(r_obs), log_pi) +
           stan::math::dot_product(stan::math::to_vector(nr_obs), log_inv_pi));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T5__, typename T7__, typename T8__, typename T10__,
          stan::require_all_t<stan::is_stan_scalar<T5__>,
                              stan::is_eigen_matrix_dynamic<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_stan_scalar<T8__>,
                              stan::is_stan_scalar<T10__>>*>
Eigen::Matrix<stan::promote_args_t<T5__, stan::base_type_t<T7__>, T8__,
                T10__>,-1,1>
blrm_mix_lpmf_comp(const int& g, const int& num_groups,
                   const std::vector<int>& obs_gidx, const std::vector<int>&
                   r, const std::vector<int>& n,
                   const std::vector<Eigen::Matrix<T5__,-1,-1>>& X_comp,
                   const std::vector<std::vector<int>>& finite_cov,
                   const T7__& X_inter_arg__,
                   const std::vector<std::vector<Eigen::Matrix<T8__,-1,1>>>&
                   beta, const std::vector<std::vector<int>>& mix_idx_beta,
                   const std::vector<Eigen::Matrix<T10__,-1,1>>& eta,
                   const std::vector<std::vector<int>>& mix_idx_eta,
                   std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T5__,
                             stan::base_type_t<T7__>, T8__, T10__>;
  int current_statement__ = 0;
  const auto& X_inter = stan::math::to_ref(X_inter_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int num_mix_comp = std::numeric_limits<int>::min();
    current_statement__ = 732;
    num_mix_comp = stan::math::size(mix_idx_beta);
    int num_comp = std::numeric_limits<int>::min();
    current_statement__ = 733;
    num_comp = stan::model::rvalue(stan::math::dims(mix_idx_beta),
                 "dims(mix_idx_beta)", stan::model::index_uni(2));
    int num_inter = std::numeric_limits<int>::min();
    current_statement__ = 734;
    num_inter = stan::model::rvalue(stan::math::dims(mix_idx_eta),
                  "dims(mix_idx_eta)", stan::model::index_uni(2));
    current_statement__ = 735;
    stan::math::validate_non_negative_index("mix_lpmf", "num_mix_comp",
      num_mix_comp);
    Eigen::Matrix<local_scalar_t__,-1,1> mix_lpmf =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_mix_comp,
        DUMMY_VAR__);
    current_statement__ = 739;
    if (stan::math::logical_eq(stan::math::num_elements(r), 0)) {
      current_statement__ = 737;
      return stan::math::rep_vector(0.0, num_mix_comp);
    }
    current_statement__ = 756;
    for (int m = 1; m <= num_mix_comp; ++m) {
      current_statement__ = 740;
      stan::math::validate_non_negative_index("ind_beta", "num_comp",
        num_comp);
      std::vector<int> ind_beta =
        std::vector<int>(num_comp, std::numeric_limits<int>::min());
      current_statement__ = 741;
      stan::model::assign(ind_beta,
        stan::model::rvalue(mix_idx_beta, "mix_idx_beta",
          stan::model::index_uni(m)), "assigning variable ind_beta");
      current_statement__ = 742;
      stan::math::validate_non_negative_index("ind_eta", "num_inter",
        num_inter);
      std::vector<int> ind_eta =
        std::vector<int>(num_inter, std::numeric_limits<int>::min());
      current_statement__ = 743;
      stan::model::assign(ind_eta,
        stan::model::rvalue(mix_idx_eta, "mix_idx_eta",
          stan::model::index_uni(m)), "assigning variable ind_eta");
      current_statement__ = 744;
      stan::math::validate_non_negative_index("beta_mix_config", "num_comp",
        num_comp);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> beta_mix_config =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
      current_statement__ = 746;
      stan::math::validate_non_negative_index("eta_mix_config", "num_inter",
        num_inter);
      Eigen::Matrix<local_scalar_t__,-1,1> eta_mix_config =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
          DUMMY_VAR__);
      current_statement__ = 750;
      for (int i = 1; i <= num_comp; ++i) {
        current_statement__ = 748;
        stan::model::assign(beta_mix_config,
          stan::model::rvalue(beta, "beta",
            stan::model::index_uni(
              (stan::math::logical_eq(
                 stan::model::rvalue(ind_beta, "ind_beta",
                   stan::model::index_uni(i)), 1) ? g : (g + num_groups))),
            stan::model::index_uni(i)), "assigning variable beta_mix_config",
          stan::model::index_uni(i));
      }
      current_statement__ = 753;
      for (int i = 1; i <= num_inter; ++i) {
        current_statement__ = 751;
        stan::model::assign(eta_mix_config,
          stan::model::rvalue(eta, "eta",
            stan::model::index_uni(
              (stan::math::logical_eq(
                 stan::model::rvalue(ind_eta, "ind_eta",
                   stan::model::index_uni(i)), 1) ? g : (g + num_groups))),
            stan::model::index_uni(i)), "assigning variable eta_mix_config",
          stan::model::index_uni(i));
      }
      current_statement__ = 754;
      stan::model::assign(mix_lpmf,
        blrm_lpmf<false>(r, obs_gidx, n, X_comp, finite_cov, X_inter,
          beta_mix_config, eta_mix_config, pstream__),
        "assigning variable mix_lpmf", stan::model::index_uni(m));
    }
    current_statement__ = 757;
    return mix_lpmf;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T5__, typename T7__, typename T8__, typename T10__,
          stan::require_all_t<stan::is_stan_scalar<T5__>,
                              stan::is_eigen_matrix_dynamic<T7__>,
                              stan::is_vt_not_complex<T7__>,
                              stan::is_stan_scalar<T8__>,
                              stan::is_stan_scalar<T10__>>*>
Eigen::Matrix<stan::promote_args_t<T5__, stan::base_type_t<T7__>, T8__,
                T10__>,-1,1>
blrm_mix_lupmf_comp(const int& g, const int& num_groups,
                    const std::vector<int>& obs_gidx, const std::vector<int>&
                    r, const std::vector<int>& n,
                    const std::vector<Eigen::Matrix<T5__,-1,-1>>& X_comp,
                    const std::vector<std::vector<int>>& finite_cov,
                    const T7__& X_inter_arg__,
                    const std::vector<std::vector<Eigen::Matrix<T8__,-1,1>>>&
                    beta, const std::vector<std::vector<int>>& mix_idx_beta,
                    const std::vector<Eigen::Matrix<T10__,-1,1>>& eta,
                    const std::vector<std::vector<int>>& mix_idx_eta,
                    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T5__,
                             stan::base_type_t<T7__>, T8__, T10__>;
  int current_statement__ = 0;
  const auto& X_inter = stan::math::to_ref(X_inter_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int num_mix_comp = std::numeric_limits<int>::min();
    current_statement__ = 759;
    num_mix_comp = stan::math::size(mix_idx_beta);
    int num_comp = std::numeric_limits<int>::min();
    current_statement__ = 760;
    num_comp = stan::model::rvalue(stan::math::dims(mix_idx_beta),
                 "dims(mix_idx_beta)", stan::model::index_uni(2));
    int num_inter = std::numeric_limits<int>::min();
    current_statement__ = 761;
    num_inter = stan::model::rvalue(stan::math::dims(mix_idx_eta),
                  "dims(mix_idx_eta)", stan::model::index_uni(2));
    current_statement__ = 762;
    stan::math::validate_non_negative_index("mix_ll", "num_mix_comp",
      num_mix_comp);
    Eigen::Matrix<local_scalar_t__,-1,1> mix_ll =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_mix_comp,
        DUMMY_VAR__);
    current_statement__ = 766;
    if (stan::math::logical_eq(stan::math::num_elements(r), 0)) {
      current_statement__ = 764;
      return stan::math::rep_vector(0.0, num_mix_comp);
    }
    current_statement__ = 783;
    for (int m = 1; m <= num_mix_comp; ++m) {
      current_statement__ = 767;
      stan::math::validate_non_negative_index("ind_beta", "num_comp",
        num_comp);
      std::vector<int> ind_beta =
        std::vector<int>(num_comp, std::numeric_limits<int>::min());
      current_statement__ = 768;
      stan::model::assign(ind_beta,
        stan::model::rvalue(mix_idx_beta, "mix_idx_beta",
          stan::model::index_uni(m)), "assigning variable ind_beta");
      current_statement__ = 769;
      stan::math::validate_non_negative_index("ind_eta", "num_inter",
        num_inter);
      std::vector<int> ind_eta =
        std::vector<int>(num_inter, std::numeric_limits<int>::min());
      current_statement__ = 770;
      stan::model::assign(ind_eta,
        stan::model::rvalue(mix_idx_eta, "mix_idx_eta",
          stan::model::index_uni(m)), "assigning variable ind_eta");
      current_statement__ = 771;
      stan::math::validate_non_negative_index("beta_mix_config", "num_comp",
        num_comp);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> beta_mix_config =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
      current_statement__ = 773;
      stan::math::validate_non_negative_index("eta_mix_config", "num_inter",
        num_inter);
      Eigen::Matrix<local_scalar_t__,-1,1> eta_mix_config =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
          DUMMY_VAR__);
      current_statement__ = 777;
      for (int i = 1; i <= num_comp; ++i) {
        current_statement__ = 775;
        stan::model::assign(beta_mix_config,
          stan::model::rvalue(beta, "beta",
            stan::model::index_uni(
              (stan::math::logical_eq(
                 stan::model::rvalue(ind_beta, "ind_beta",
                   stan::model::index_uni(i)), 1) ? g : (g + num_groups))),
            stan::model::index_uni(i)), "assigning variable beta_mix_config",
          stan::model::index_uni(i));
      }
      current_statement__ = 780;
      for (int i = 1; i <= num_inter; ++i) {
        current_statement__ = 778;
        stan::model::assign(eta_mix_config,
          stan::model::rvalue(eta, "eta",
            stan::model::index_uni(
              (stan::math::logical_eq(
                 stan::model::rvalue(ind_eta, "ind_eta",
                   stan::model::index_uni(i)), 1) ? g : (g + num_groups))),
            stan::model::index_uni(i)), "assigning variable eta_mix_config",
          stan::model::index_uni(i));
      }
      current_statement__ = 781;
      stan::model::assign(mix_ll,
        blrm_lupmf_comp(r, obs_gidx, n, X_comp, finite_cov, X_inter,
          beta_mix_config, eta_mix_config, pstream__),
        "assigning variable mix_ll", stan::model::index_uni(m));
    }
    current_statement__ = 784;
    return mix_ll;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
block_cholesky_decompose(const T0__& A_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& A = stan::math::to_ref(A_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int nr = std::numeric_limits<int>::min();
    current_statement__ = 786;
    nr = stan::math::rows(A);
    int nc = std::numeric_limits<int>::min();
    current_statement__ = 787;
    nc = stan::math::cols(A);
    current_statement__ = 788;
    stan::math::validate_non_negative_index("L", "nc", nc);
    current_statement__ = 789;
    stan::math::validate_non_negative_index("L", "nc", nc);
    Eigen::Matrix<local_scalar_t__,-1,-1> L =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(nc, nc, DUMMY_VAR__);
    current_statement__ = 790;
    stan::model::assign(L, stan::math::rep_matrix(0.0, nc, nc),
      "assigning variable L");
    current_statement__ = 791;
    stan::math::validate_non_negative_index("is_zero", "nr", nr);
    std::vector<int> is_zero =
      std::vector<int>(nr, std::numeric_limits<int>::min());
    current_statement__ = 792;
    stan::model::assign(is_zero, stan::math::rep_array(0, nr),
      "assigning variable is_zero");
    int start_index = std::numeric_limits<int>::min();
    current_statement__ = 793;
    start_index = 1;
    int end_index = std::numeric_limits<int>::min();
    current_statement__ = 794;
    end_index = nr;
    current_statement__ = 796;
    if (stan::math::logical_neq(nr, nc)) {
      current_statement__ = 795;
      std::stringstream errmsg_stream__;
      stan::math::stan_print(&errmsg_stream__,
        "Can only cholesky decompose a square matrix! Columns: ");
      stan::math::stan_print(&errmsg_stream__, nc);
      stan::math::stan_print(&errmsg_stream__, "; Rows: ");
      stan::math::stan_print(&errmsg_stream__, nr);
      throw std::domain_error(errmsg_stream__.str());
    }
    current_statement__ = 808;
    for (int i = 1; i <= nr; ++i) {
      int col_zero = std::numeric_limits<int>::min();
      current_statement__ = 797;
      col_zero = 0;
      int row_zero = std::numeric_limits<int>::min();
      current_statement__ = 798;
      row_zero = 0;
      current_statement__ = 804;
      for (int j = 1; j <= nr; ++j) {
        current_statement__ = 800;
        if (stan::math::logical_eq(
              stan::model::rvalue(A, "A", stan::model::index_uni(i),
                stan::model::index_uni(j)), 0)) {
          current_statement__ = 799;
          col_zero = (col_zero + 1);
        }
        current_statement__ = 802;
        if (stan::math::logical_eq(
              stan::model::rvalue(A, "A", stan::model::index_uni(j),
                stan::model::index_uni(i)), 0)) {
          current_statement__ = 801;
          row_zero = (row_zero + 1);
        }
      }
      current_statement__ = 806;
      if ((stan::math::primitive_value(stan::math::logical_eq(col_zero, nc))
          &&
          stan::math::primitive_value(stan::math::logical_eq(row_zero, nr)))) {
        current_statement__ = 805;
        stan::model::assign(is_zero, 1, "assigning variable is_zero",
          stan::model::index_uni(i));
      }
    }
    current_statement__ = 810;
    if (stan::math::logical_eq(stan::math::sum(is_zero), nr)) {
      current_statement__ = 809;
      return L;
    }
    current_statement__ = 812;
    while ((stan::math::primitive_value(
              stan::math::logical_neq(start_index, nr))
           &&
           stan::math::primitive_value(
             stan::math::logical_eq(
               stan::model::rvalue(is_zero, "is_zero",
                 stan::model::index_uni(start_index)), 1)))) {
      current_statement__ = 811;
      start_index = (start_index + 1);
    }
    current_statement__ = 814;
    while ((stan::math::primitive_value(
              stan::math::logical_neq(start_index, end_index))
           &&
           stan::math::primitive_value(
             stan::math::logical_eq(
               stan::model::rvalue(is_zero, "is_zero",
                 stan::model::index_uni(end_index)), 1)))) {
      current_statement__ = 813;
      end_index = (end_index - 1);
    }
    current_statement__ = 815;
    stan::model::assign(L,
      stan::math::cholesky_decompose(
        stan::model::rvalue(A, "A",
          stan::model::index_min_max(start_index, end_index),
          stan::model::index_min_max(start_index, end_index))),
      "assigning variable L",
      stan::model::index_min_max(start_index, end_index),
      stan::model::index_min_max(start_index, end_index));
    current_statement__ = 816;
    return L;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
#include <stan_meta_header.hpp>
class model_blrm_exnex final : public model_base_crtp<model_blrm_exnex> {
private:
  int num_obs;
  std::vector<int> r;
  std::vector<int> nr;
  int num_comp;
  std::vector<Eigen::Matrix<double,-1,-1>> X_comp;
  int num_inter;
  Eigen::Matrix<double,-1,-1> X_inter_data__;
  std::vector<int> group;
  std::vector<int> stratum;
  int num_groups;
  int num_strata;
  std::vector<int> group_stratum_cid;
  std::vector<int> prior_is_EXNEX_comp;
  std::vector<int> prior_is_EXNEX_inter;
  Eigen::Matrix<double,-1,-1> prior_EX_prob_comp_data__;
  Eigen::Matrix<double,-1,-1> prior_EX_prob_inter_data__;
  std::vector<int> prior_EX_mu_comp_Nc;
  std::vector<Eigen::Matrix<double,-1,1>> prior_EX_mu_comp_w;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>> prior_EX_mu_comp_m;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>
    prior_EX_mu_comp_sigma;
  std::vector<std::vector<int>> prior_EX_tau_comp_Nc;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>> prior_EX_tau_comp_w;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,1>>>>
    prior_EX_tau_comp_m;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>>
    prior_EX_tau_comp_sigma;
  std::vector<double> prior_EX_corr_eta_comp;
  int prior_EX_mu_inter_Nc;
  Eigen::Matrix<double,-1,1> prior_EX_mu_inter_w_data__;
  std::vector<Eigen::Matrix<double,-1,1>> prior_EX_mu_inter_m;
  std::vector<Eigen::Matrix<double,-1,-1>> prior_EX_mu_inter_sigma;
  std::vector<int> prior_EX_tau_inter_Nc;
  std::vector<Eigen::Matrix<double,-1,1>> prior_EX_tau_inter_w;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>> prior_EX_tau_inter_m;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>
    prior_EX_tau_inter_sigma;
  double prior_EX_corr_eta_inter;
  std::vector<int> prior_NEX_mu_comp_Nc;
  std::vector<Eigen::Matrix<double,-1,1>> prior_NEX_mu_comp_w;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>> prior_NEX_mu_comp_m;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>
    prior_NEX_mu_comp_sigma;
  int prior_NEX_mu_inter_Nc;
  Eigen::Matrix<double,-1,1> prior_NEX_mu_inter_w_data__;
  std::vector<Eigen::Matrix<double,-1,1>> prior_NEX_mu_inter_m;
  std::vector<Eigen::Matrix<double,-1,-1>> prior_NEX_mu_inter_sigma;
  int prior_tau_dist;
  int prior_PD;
  std::vector<int> n;
  std::vector<std::vector<int>> finite_cov;
  int num_EXNEX_comp;
  int num_EXNEX_inter;
  int num_mix_dim;
  int num_mix_comp;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>
    prior_EX_mu_comp_sigma_L;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>
    prior_NEX_mu_comp_sigma_L;
  std::vector<Eigen::Matrix<double,-1,-1>> prior_EX_mu_inter_sigma_L;
  std::vector<Eigen::Matrix<double,-1,-1>> prior_NEX_mu_inter_sigma_L;
  std::vector<std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>>
    prior_EX_tau_comp_sigma_L;
  std::vector<std::vector<Eigen::Matrix<double,-1,-1>>>
    prior_EX_tau_inter_sigma_L;
  std::vector<std::vector<Eigen::Matrix<double,-1,1>>> prior_EX_tau_comp_mean;
  std::vector<Eigen::Matrix<double,-1,1>> prior_EX_tau_inter_mean;
  std::vector<std::vector<int>> mix_is_EX_beta;
  std::vector<std::vector<int>> mix_is_EX_eta;
  std::vector<std::vector<int>> mix_idx_beta;
  std::vector<std::vector<int>> mix_idx_eta;
  std::vector<int> num_obs_group;
  std::vector<int> num_cases_group;
  std::vector<std::vector<int>> group_obs_idx;
  std::vector<Eigen::Matrix<double,-1,1>> mix_log_weight;
  Eigen::Matrix<double,-1,1> log_normfactor_group_data__;
  int log_beta_raw_1dim__;
  int eta_raw_1dim__;
  int beta_1dim__;
  int eta_1dim__;
  Eigen::Map<Eigen::Matrix<double,-1,-1>> X_inter{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> prior_EX_prob_comp{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> prior_EX_prob_inter{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_EX_mu_inter_w{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> prior_NEX_mu_inter_w{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> log_normfactor_group{nullptr, 0};
public:
  ~model_blrm_exnex() {}
  model_blrm_exnex(stan::io::var_context& context__, unsigned int
                   random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "model_blrm_exnex_namespace::model_blrm_exnex";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 142;
      context__.validate_dims("data initialization", "num_obs", "int",
        std::vector<size_t>{});
      num_obs = std::numeric_limits<int>::min();
      current_statement__ = 142;
      num_obs = context__.vals_i("num_obs")[(1 - 1)];
      current_statement__ = 142;
      stan::math::check_greater_or_equal(function__, "num_obs", num_obs, 0);
      current_statement__ = 143;
      stan::math::validate_non_negative_index("r", "num_obs", num_obs);
      current_statement__ = 144;
      context__.validate_dims("data initialization", "r", "int",
        std::vector<size_t>{static_cast<size_t>(num_obs)});
      r = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      current_statement__ = 144;
      r = context__.vals_i("r");
      current_statement__ = 144;
      stan::math::check_greater_or_equal(function__, "r", r, 0);
      current_statement__ = 145;
      stan::math::validate_non_negative_index("nr", "num_obs", num_obs);
      current_statement__ = 146;
      context__.validate_dims("data initialization", "nr", "int",
        std::vector<size_t>{static_cast<size_t>(num_obs)});
      nr = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      current_statement__ = 146;
      nr = context__.vals_i("nr");
      current_statement__ = 146;
      stan::math::check_greater_or_equal(function__, "nr", nr, 0);
      current_statement__ = 147;
      context__.validate_dims("data initialization", "num_comp", "int",
        std::vector<size_t>{});
      num_comp = std::numeric_limits<int>::min();
      current_statement__ = 147;
      num_comp = context__.vals_i("num_comp")[(1 - 1)];
      current_statement__ = 147;
      stan::math::check_greater_or_equal(function__, "num_comp", num_comp, 1);
      current_statement__ = 148;
      stan::math::validate_non_negative_index("X_comp", "num_comp", num_comp);
      current_statement__ = 149;
      stan::math::validate_non_negative_index("X_comp", "num_obs", num_obs);
      current_statement__ = 150;
      context__.validate_dims("data initialization", "X_comp", "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(num_obs), static_cast<size_t>(2)});
      X_comp = std::vector<Eigen::Matrix<double,-1,-1>>(num_comp,
                 Eigen::Matrix<double,-1,-1>::Constant(num_obs, 2,
                   std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> X_comp_flat__;
        current_statement__ = 150;
        X_comp_flat__ = context__.vals_r("X_comp");
        current_statement__ = 150;
        pos__ = 1;
        current_statement__ = 150;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 150;
          for (int sym2__ = 1; sym2__ <= num_obs; ++sym2__) {
            current_statement__ = 150;
            for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
              current_statement__ = 150;
              stan::model::assign(X_comp, X_comp_flat__[(pos__ - 1)],
                "assigning variable X_comp", stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 150;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 151;
      context__.validate_dims("data initialization", "num_inter", "int",
        std::vector<size_t>{});
      num_inter = std::numeric_limits<int>::min();
      current_statement__ = 151;
      num_inter = context__.vals_i("num_inter")[(1 - 1)];
      current_statement__ = 151;
      stan::math::check_greater_or_equal(function__, "num_inter", num_inter,
        0);
      current_statement__ = 152;
      stan::math::validate_non_negative_index("X_inter", "num_obs", num_obs);
      current_statement__ = 153;
      stan::math::validate_non_negative_index("X_inter", "num_inter",
        num_inter);
      current_statement__ = 154;
      context__.validate_dims("data initialization", "X_inter", "double",
        std::vector<size_t>{static_cast<size_t>(num_obs),
          static_cast<size_t>(num_inter)});
      X_inter_data__ = Eigen::Matrix<double,-1,-1>::Constant(num_obs,
                         num_inter, std::numeric_limits<double>::quiet_NaN());
      new (&X_inter)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_inter_data__.data(),
        num_obs, num_inter);
      {
        std::vector<local_scalar_t__> X_inter_flat__;
        current_statement__ = 154;
        X_inter_flat__ = context__.vals_r("X_inter");
        current_statement__ = 154;
        pos__ = 1;
        current_statement__ = 154;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 154;
          for (int sym2__ = 1; sym2__ <= num_obs; ++sym2__) {
            current_statement__ = 154;
            stan::model::assign(X_inter, X_inter_flat__[(pos__ - 1)],
              "assigning variable X_inter", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 154;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 155;
      stan::math::validate_non_negative_index("group", "num_obs", num_obs);
      current_statement__ = 156;
      context__.validate_dims("data initialization", "group", "int",
        std::vector<size_t>{static_cast<size_t>(num_obs)});
      group = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      current_statement__ = 156;
      group = context__.vals_i("group");
      current_statement__ = 156;
      stan::math::check_greater_or_equal(function__, "group", group, 1);
      current_statement__ = 157;
      stan::math::validate_non_negative_index("stratum", "num_obs", num_obs);
      current_statement__ = 158;
      context__.validate_dims("data initialization", "stratum", "int",
        std::vector<size_t>{static_cast<size_t>(num_obs)});
      stratum = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      current_statement__ = 158;
      stratum = context__.vals_i("stratum");
      current_statement__ = 158;
      stan::math::check_greater_or_equal(function__, "stratum", stratum, 1);
      current_statement__ = 159;
      context__.validate_dims("data initialization", "num_groups", "int",
        std::vector<size_t>{});
      num_groups = std::numeric_limits<int>::min();
      current_statement__ = 159;
      num_groups = context__.vals_i("num_groups")[(1 - 1)];
      current_statement__ = 159;
      stan::math::check_greater_or_equal(function__, "num_groups",
        num_groups, 1);
      current_statement__ = 160;
      context__.validate_dims("data initialization", "num_strata", "int",
        std::vector<size_t>{});
      num_strata = std::numeric_limits<int>::min();
      current_statement__ = 160;
      num_strata = context__.vals_i("num_strata")[(1 - 1)];
      current_statement__ = 160;
      stan::math::check_greater_or_equal(function__, "num_strata",
        num_strata, 1);
      current_statement__ = 161;
      stan::math::validate_non_negative_index("group_stratum_cid",
        "num_groups", num_groups);
      current_statement__ = 162;
      context__.validate_dims("data initialization", "group_stratum_cid",
        "int", std::vector<size_t>{static_cast<size_t>(num_groups)});
      group_stratum_cid = std::vector<int>(num_groups,
                            std::numeric_limits<int>::min());
      current_statement__ = 162;
      group_stratum_cid = context__.vals_i("group_stratum_cid");
      current_statement__ = 162;
      stan::math::check_greater_or_equal(function__, "group_stratum_cid",
        group_stratum_cid, 1);
      current_statement__ = 162;
      stan::math::check_less_or_equal(function__, "group_stratum_cid",
        group_stratum_cid, num_strata);
      current_statement__ = 163;
      stan::math::validate_non_negative_index("prior_is_EXNEX_comp",
        "num_comp", num_comp);
      current_statement__ = 164;
      context__.validate_dims("data initialization", "prior_is_EXNEX_comp",
        "int", std::vector<size_t>{static_cast<size_t>(num_comp)});
      prior_is_EXNEX_comp = std::vector<int>(num_comp,
                              std::numeric_limits<int>::min());
      current_statement__ = 164;
      prior_is_EXNEX_comp = context__.vals_i("prior_is_EXNEX_comp");
      current_statement__ = 164;
      stan::math::check_greater_or_equal(function__, "prior_is_EXNEX_comp",
        prior_is_EXNEX_comp, 0);
      current_statement__ = 164;
      stan::math::check_less_or_equal(function__, "prior_is_EXNEX_comp",
        prior_is_EXNEX_comp, 1);
      current_statement__ = 165;
      stan::math::validate_non_negative_index("prior_is_EXNEX_inter",
        "num_inter", num_inter);
      current_statement__ = 166;
      context__.validate_dims("data initialization", "prior_is_EXNEX_inter",
        "int", std::vector<size_t>{static_cast<size_t>(num_inter)});
      prior_is_EXNEX_inter = std::vector<int>(num_inter,
                               std::numeric_limits<int>::min());
      current_statement__ = 166;
      prior_is_EXNEX_inter = context__.vals_i("prior_is_EXNEX_inter");
      current_statement__ = 166;
      stan::math::check_greater_or_equal(function__, "prior_is_EXNEX_inter",
        prior_is_EXNEX_inter, 0);
      current_statement__ = 166;
      stan::math::check_less_or_equal(function__, "prior_is_EXNEX_inter",
        prior_is_EXNEX_inter, 1);
      current_statement__ = 167;
      stan::math::validate_non_negative_index("prior_EX_prob_comp",
        "num_groups", num_groups);
      current_statement__ = 168;
      stan::math::validate_non_negative_index("prior_EX_prob_comp",
        "num_comp", num_comp);
      current_statement__ = 169;
      context__.validate_dims("data initialization", "prior_EX_prob_comp",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_groups),
          static_cast<size_t>(num_comp)});
      prior_EX_prob_comp_data__ = Eigen::Matrix<double,-1,-1>::Constant(num_groups,
                                    num_comp,
                                    std::numeric_limits<double>::quiet_NaN());
      new (&prior_EX_prob_comp)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(prior_EX_prob_comp_data__.data(),
        num_groups, num_comp);
      {
        std::vector<local_scalar_t__> prior_EX_prob_comp_flat__;
        current_statement__ = 169;
        prior_EX_prob_comp_flat__ = context__.vals_r("prior_EX_prob_comp");
        current_statement__ = 169;
        pos__ = 1;
        current_statement__ = 169;
        for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
          current_statement__ = 169;
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            current_statement__ = 169;
            stan::model::assign(prior_EX_prob_comp,
              prior_EX_prob_comp_flat__[(pos__ - 1)],
              "assigning variable prior_EX_prob_comp",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 169;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 169;
      stan::math::check_greater_or_equal(function__, "prior_EX_prob_comp",
        prior_EX_prob_comp, 1E-6);
      current_statement__ = 169;
      stan::math::check_less_or_equal(function__, "prior_EX_prob_comp",
        prior_EX_prob_comp, 1);
      current_statement__ = 170;
      stan::math::validate_non_negative_index("prior_EX_prob_inter",
        "num_groups", num_groups);
      current_statement__ = 171;
      stan::math::validate_non_negative_index("prior_EX_prob_inter",
        "num_inter", num_inter);
      current_statement__ = 172;
      context__.validate_dims("data initialization", "prior_EX_prob_inter",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_groups),
          static_cast<size_t>(num_inter)});
      prior_EX_prob_inter_data__ = Eigen::Matrix<double,-1,-1>::Constant(num_groups,
                                     num_inter,
                                     std::numeric_limits<double>::quiet_NaN());
      new (&prior_EX_prob_inter)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(prior_EX_prob_inter_data__.data(),
        num_groups, num_inter);
      {
        std::vector<local_scalar_t__> prior_EX_prob_inter_flat__;
        current_statement__ = 172;
        prior_EX_prob_inter_flat__ = context__.vals_r("prior_EX_prob_inter");
        current_statement__ = 172;
        pos__ = 1;
        current_statement__ = 172;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 172;
          for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
            current_statement__ = 172;
            stan::model::assign(prior_EX_prob_inter,
              prior_EX_prob_inter_flat__[(pos__ - 1)],
              "assigning variable prior_EX_prob_inter",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 172;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 172;
      stan::math::check_greater_or_equal(function__, "prior_EX_prob_inter",
        prior_EX_prob_inter, 1E-6);
      current_statement__ = 172;
      stan::math::check_less_or_equal(function__, "prior_EX_prob_inter",
        prior_EX_prob_inter, 1);
      current_statement__ = 173;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_Nc",
        "num_comp", num_comp);
      current_statement__ = 174;
      context__.validate_dims("data initialization", "prior_EX_mu_comp_Nc",
        "int", std::vector<size_t>{static_cast<size_t>(num_comp)});
      prior_EX_mu_comp_Nc = std::vector<int>(num_comp,
                              std::numeric_limits<int>::min());
      current_statement__ = 174;
      prior_EX_mu_comp_Nc = context__.vals_i("prior_EX_mu_comp_Nc");
      current_statement__ = 175;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_w",
        "num_comp", num_comp);
      current_statement__ = 176;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_w",
        "max_int(prior_EX_mu_comp_Nc)",
        max_int(prior_EX_mu_comp_Nc, pstream__));
      current_statement__ = 177;
      context__.validate_dims("data initialization", "prior_EX_mu_comp_w",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(max_int(prior_EX_mu_comp_Nc, pstream__))});
      prior_EX_mu_comp_w = std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
                             Eigen::Matrix<double,-1,1>::Constant(max_int(
                                                                    prior_EX_mu_comp_Nc,
                                                                    pstream__),
                               std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> prior_EX_mu_comp_w_flat__;
        current_statement__ = 177;
        prior_EX_mu_comp_w_flat__ = context__.vals_r("prior_EX_mu_comp_w");
        current_statement__ = 177;
        pos__ = 1;
        current_statement__ = 177;
        for (int sym1__ = 1; sym1__ <=
             max_int(prior_EX_mu_comp_Nc, pstream__); ++sym1__) {
          current_statement__ = 177;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 177;
            stan::model::assign(prior_EX_mu_comp_w,
              prior_EX_mu_comp_w_flat__[(pos__ - 1)],
              "assigning variable prior_EX_mu_comp_w",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 177;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 178;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_m",
        "num_comp", num_comp);
      current_statement__ = 179;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_m",
        "max_int(prior_EX_mu_comp_Nc)",
        max_int(prior_EX_mu_comp_Nc, pstream__));
      current_statement__ = 180;
      context__.validate_dims("data initialization", "prior_EX_mu_comp_m",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(max_int(prior_EX_mu_comp_Nc, pstream__)),
          static_cast<size_t>(2)});
      prior_EX_mu_comp_m = std::vector<
                             std::vector<Eigen::Matrix<double,-1,1>>>(num_comp,
                             std::vector<Eigen::Matrix<double,-1,1>>(
                               max_int(prior_EX_mu_comp_Nc, pstream__),
                               Eigen::Matrix<double,-1,1>::Constant(2,
                                 std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> prior_EX_mu_comp_m_flat__;
        current_statement__ = 180;
        prior_EX_mu_comp_m_flat__ = context__.vals_r("prior_EX_mu_comp_m");
        current_statement__ = 180;
        pos__ = 1;
        current_statement__ = 180;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 180;
          for (int sym2__ = 1; sym2__ <=
               max_int(prior_EX_mu_comp_Nc, pstream__); ++sym2__) {
            current_statement__ = 180;
            for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
              current_statement__ = 180;
              stan::model::assign(prior_EX_mu_comp_m,
                prior_EX_mu_comp_m_flat__[(pos__ - 1)],
                "assigning variable prior_EX_mu_comp_m",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 180;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 181;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_sigma",
        "num_comp", num_comp);
      current_statement__ = 182;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_sigma",
        "max_int(prior_EX_mu_comp_Nc)",
        max_int(prior_EX_mu_comp_Nc, pstream__));
      current_statement__ = 183;
      context__.validate_dims("data initialization",
        "prior_EX_mu_comp_sigma", "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(max_int(prior_EX_mu_comp_Nc, pstream__)),
          static_cast<size_t>(2), static_cast<size_t>(2)});
      prior_EX_mu_comp_sigma = std::vector<
                                 std::vector<Eigen::Matrix<double,-1,-1>>>(num_comp,
                                 std::vector<Eigen::Matrix<double,-1,-1>>(
                                   max_int(prior_EX_mu_comp_Nc, pstream__),
                                   Eigen::Matrix<double,-1,-1>::Constant(2,
                                     2,
                                     std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> prior_EX_mu_comp_sigma_flat__;
        current_statement__ = 183;
        prior_EX_mu_comp_sigma_flat__ = context__.vals_r("prior_EX_mu_comp_sigma");
        current_statement__ = 183;
        pos__ = 1;
        current_statement__ = 183;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 183;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 183;
            for (int sym3__ = 1; sym3__ <=
                 max_int(prior_EX_mu_comp_Nc, pstream__); ++sym3__) {
              current_statement__ = 183;
              for (int sym4__ = 1; sym4__ <= num_comp; ++sym4__) {
                current_statement__ = 183;
                stan::model::assign(prior_EX_mu_comp_sigma,
                  prior_EX_mu_comp_sigma_flat__[(pos__ - 1)],
                  "assigning variable prior_EX_mu_comp_sigma",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                current_statement__ = 183;
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 184;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_Nc",
        "num_strata", num_strata);
      current_statement__ = 185;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_Nc",
        "num_comp", num_comp);
      current_statement__ = 186;
      context__.validate_dims("data initialization", "prior_EX_tau_comp_Nc",
        "int",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(num_comp)});
      prior_EX_tau_comp_Nc = std::vector<std::vector<int>>(num_strata,
                               std::vector<int>(num_comp,
                                 std::numeric_limits<int>::min()));
      {
        std::vector<int> prior_EX_tau_comp_Nc_flat__;
        current_statement__ = 186;
        prior_EX_tau_comp_Nc_flat__ = context__.vals_i("prior_EX_tau_comp_Nc");
        current_statement__ = 186;
        pos__ = 1;
        current_statement__ = 186;
        for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
          current_statement__ = 186;
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            current_statement__ = 186;
            stan::model::assign(prior_EX_tau_comp_Nc,
              prior_EX_tau_comp_Nc_flat__[(pos__ - 1)],
              "assigning variable prior_EX_tau_comp_Nc",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 186;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 187;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_w",
        "num_strata", num_strata);
      current_statement__ = 188;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_w",
        "num_comp", num_comp);
      current_statement__ = 189;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_w",
        "max_int(to_array_1d(prior_EX_tau_comp_Nc))",
        max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__));
      current_statement__ = 190;
      context__.validate_dims("data initialization", "prior_EX_tau_comp_w",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(num_comp),
          static_cast<size_t>(
            max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__))});
      prior_EX_tau_comp_w = std::vector<
                              std::vector<Eigen::Matrix<double,-1,1>>>(num_strata,
                              std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
                                Eigen::Matrix<double,-1,1>::Constant(
                                  max_int(
                                    stan::math::to_array_1d(
                                      prior_EX_tau_comp_Nc), pstream__),
                                  std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> prior_EX_tau_comp_w_flat__;
        current_statement__ = 190;
        prior_EX_tau_comp_w_flat__ = context__.vals_r("prior_EX_tau_comp_w");
        current_statement__ = 190;
        pos__ = 1;
        current_statement__ = 190;
        for (int sym1__ = 1; sym1__ <=
             max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__); ++sym1__) {
          current_statement__ = 190;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 190;
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              current_statement__ = 190;
              stan::model::assign(prior_EX_tau_comp_w,
                prior_EX_tau_comp_w_flat__[(pos__ - 1)],
                "assigning variable prior_EX_tau_comp_w",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 190;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 191;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_m",
        "num_strata", num_strata);
      current_statement__ = 192;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_m",
        "num_comp", num_comp);
      current_statement__ = 193;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_m",
        "max_int(to_array_1d(prior_EX_tau_comp_Nc))",
        max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__));
      current_statement__ = 194;
      context__.validate_dims("data initialization", "prior_EX_tau_comp_m",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(num_comp),
          static_cast<size_t>(
            max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__)),
          static_cast<size_t>(2)});
      prior_EX_tau_comp_m = std::vector<
                              std::vector<
                                std::vector<Eigen::Matrix<double,-1,1>>>>(num_strata,
                              std::vector<
                                std::vector<Eigen::Matrix<double,-1,1>>>(num_comp,
                                std::vector<Eigen::Matrix<double,-1,1>>(
                                  max_int(
                                    stan::math::to_array_1d(
                                      prior_EX_tau_comp_Nc), pstream__),
                                  Eigen::Matrix<double,-1,1>::Constant(2,
                                    std::numeric_limits<double>::quiet_NaN()))));
      {
        std::vector<local_scalar_t__> prior_EX_tau_comp_m_flat__;
        current_statement__ = 194;
        prior_EX_tau_comp_m_flat__ = context__.vals_r("prior_EX_tau_comp_m");
        current_statement__ = 194;
        pos__ = 1;
        current_statement__ = 194;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 194;
          for (int sym2__ = 1; sym2__ <=
               max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc),
                 pstream__); ++sym2__) {
            current_statement__ = 194;
            for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
              current_statement__ = 194;
              for (int sym4__ = 1; sym4__ <= num_strata; ++sym4__) {
                current_statement__ = 194;
                stan::model::assign(prior_EX_tau_comp_m,
                  prior_EX_tau_comp_m_flat__[(pos__ - 1)],
                  "assigning variable prior_EX_tau_comp_m",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                current_statement__ = 194;
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 195;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_sigma",
        "num_strata", num_strata);
      current_statement__ = 196;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_sigma",
        "num_comp", num_comp);
      current_statement__ = 197;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_sigma",
        "max_int(to_array_1d(prior_EX_tau_comp_Nc))",
        max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__));
      current_statement__ = 198;
      context__.validate_dims("data initialization",
        "prior_EX_tau_comp_sigma", "double",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(num_comp),
          static_cast<size_t>(
            max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__)),
          static_cast<size_t>(2), static_cast<size_t>(2)});
      prior_EX_tau_comp_sigma = std::vector<
                                  std::vector<
                                    std::vector<Eigen::Matrix<double,-1,-1>>>>(num_strata,
                                  std::vector<
                                    std::vector<Eigen::Matrix<double,-1,-1>>>(num_comp,
                                    std::vector<Eigen::Matrix<double,-1,-1>>(
                                      max_int(
                                        stan::math::to_array_1d(
                                          prior_EX_tau_comp_Nc), pstream__),
                                      Eigen::Matrix<double,-1,-1>::Constant(2,
                                        2,
                                        std::numeric_limits<double>::quiet_NaN(
                                          )))));
      {
        std::vector<local_scalar_t__> prior_EX_tau_comp_sigma_flat__;
        current_statement__ = 198;
        prior_EX_tau_comp_sigma_flat__ = context__.vals_r("prior_EX_tau_comp_sigma");
        current_statement__ = 198;
        pos__ = 1;
        current_statement__ = 198;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 198;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 198;
            for (int sym3__ = 1; sym3__ <=
                 max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc),
                   pstream__); ++sym3__) {
              current_statement__ = 198;
              for (int sym4__ = 1; sym4__ <= num_comp; ++sym4__) {
                current_statement__ = 198;
                for (int sym5__ = 1; sym5__ <= num_strata; ++sym5__) {
                  current_statement__ = 198;
                  stan::model::assign(prior_EX_tau_comp_sigma,
                    prior_EX_tau_comp_sigma_flat__[(pos__ - 1)],
                    "assigning variable prior_EX_tau_comp_sigma",
                    stan::model::index_uni(sym5__),
                    stan::model::index_uni(sym4__),
                    stan::model::index_uni(sym3__),
                    stan::model::index_uni(sym2__),
                    stan::model::index_uni(sym1__));
                  current_statement__ = 198;
                  pos__ = (pos__ + 1);
                }
              }
            }
          }
        }
      }
      current_statement__ = 199;
      stan::math::validate_non_negative_index("prior_EX_corr_eta_comp",
        "num_comp", num_comp);
      current_statement__ = 200;
      context__.validate_dims("data initialization",
        "prior_EX_corr_eta_comp", "double",
        std::vector<size_t>{static_cast<size_t>(num_comp)});
      prior_EX_corr_eta_comp = std::vector<double>(num_comp,
                                 std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 200;
      prior_EX_corr_eta_comp = context__.vals_r("prior_EX_corr_eta_comp");
      current_statement__ = 200;
      stan::math::check_greater_or_equal(function__,
        "prior_EX_corr_eta_comp", prior_EX_corr_eta_comp, 0);
      current_statement__ = 201;
      context__.validate_dims("data initialization", "prior_EX_mu_inter_Nc",
        "int", std::vector<size_t>{});
      prior_EX_mu_inter_Nc = std::numeric_limits<int>::min();
      current_statement__ = 201;
      prior_EX_mu_inter_Nc = context__.vals_i("prior_EX_mu_inter_Nc")[(1 -
        1)];
      current_statement__ = 202;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_w",
        "prior_EX_mu_inter_Nc", prior_EX_mu_inter_Nc);
      current_statement__ = 203;
      context__.validate_dims("data initialization", "prior_EX_mu_inter_w",
        "double",
        std::vector<size_t>{static_cast<size_t>(prior_EX_mu_inter_Nc)});
      prior_EX_mu_inter_w_data__ = Eigen::Matrix<double,-1,1>::Constant(prior_EX_mu_inter_Nc,
                                     std::numeric_limits<double>::quiet_NaN());
      new (&prior_EX_mu_inter_w)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_EX_mu_inter_w_data__.data(),
        prior_EX_mu_inter_Nc);
      {
        std::vector<local_scalar_t__> prior_EX_mu_inter_w_flat__;
        current_statement__ = 203;
        prior_EX_mu_inter_w_flat__ = context__.vals_r("prior_EX_mu_inter_w");
        current_statement__ = 203;
        pos__ = 1;
        current_statement__ = 203;
        for (int sym1__ = 1; sym1__ <= prior_EX_mu_inter_Nc; ++sym1__) {
          current_statement__ = 203;
          stan::model::assign(prior_EX_mu_inter_w,
            prior_EX_mu_inter_w_flat__[(pos__ - 1)],
            "assigning variable prior_EX_mu_inter_w",
            stan::model::index_uni(sym1__));
          current_statement__ = 203;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 204;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_m",
        "prior_EX_mu_inter_Nc", prior_EX_mu_inter_Nc);
      current_statement__ = 205;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_m",
        "num_inter", num_inter);
      current_statement__ = 206;
      context__.validate_dims("data initialization", "prior_EX_mu_inter_m",
        "double",
        std::vector<size_t>{static_cast<size_t>(prior_EX_mu_inter_Nc),
          static_cast<size_t>(num_inter)});
      prior_EX_mu_inter_m = std::vector<Eigen::Matrix<double,-1,1>>(prior_EX_mu_inter_Nc,
                              Eigen::Matrix<double,-1,1>::Constant(num_inter,
                                std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> prior_EX_mu_inter_m_flat__;
        current_statement__ = 206;
        prior_EX_mu_inter_m_flat__ = context__.vals_r("prior_EX_mu_inter_m");
        current_statement__ = 206;
        pos__ = 1;
        current_statement__ = 206;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 206;
          for (int sym2__ = 1; sym2__ <= prior_EX_mu_inter_Nc; ++sym2__) {
            current_statement__ = 206;
            stan::model::assign(prior_EX_mu_inter_m,
              prior_EX_mu_inter_m_flat__[(pos__ - 1)],
              "assigning variable prior_EX_mu_inter_m",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 206;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 207;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_sigma",
        "prior_EX_mu_inter_Nc", prior_EX_mu_inter_Nc);
      current_statement__ = 208;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_sigma",
        "num_inter", num_inter);
      current_statement__ = 209;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_sigma",
        "num_inter", num_inter);
      current_statement__ = 210;
      context__.validate_dims("data initialization",
        "prior_EX_mu_inter_sigma", "double",
        std::vector<size_t>{static_cast<size_t>(prior_EX_mu_inter_Nc),
          static_cast<size_t>(num_inter), static_cast<size_t>(num_inter)});
      prior_EX_mu_inter_sigma = std::vector<Eigen::Matrix<double,-1,-1>>(prior_EX_mu_inter_Nc,
                                  Eigen::Matrix<double,-1,-1>::Constant(num_inter,
                                    num_inter,
                                    std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> prior_EX_mu_inter_sigma_flat__;
        current_statement__ = 210;
        prior_EX_mu_inter_sigma_flat__ = context__.vals_r("prior_EX_mu_inter_sigma");
        current_statement__ = 210;
        pos__ = 1;
        current_statement__ = 210;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 210;
          for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
            current_statement__ = 210;
            for (int sym3__ = 1; sym3__ <= prior_EX_mu_inter_Nc; ++sym3__) {
              current_statement__ = 210;
              stan::model::assign(prior_EX_mu_inter_sigma,
                prior_EX_mu_inter_sigma_flat__[(pos__ - 1)],
                "assigning variable prior_EX_mu_inter_sigma",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 210;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 211;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_Nc",
        "num_strata", num_strata);
      current_statement__ = 212;
      context__.validate_dims("data initialization", "prior_EX_tau_inter_Nc",
        "int", std::vector<size_t>{static_cast<size_t>(num_strata)});
      prior_EX_tau_inter_Nc = std::vector<int>(num_strata,
                                std::numeric_limits<int>::min());
      current_statement__ = 212;
      prior_EX_tau_inter_Nc = context__.vals_i("prior_EX_tau_inter_Nc");
      current_statement__ = 213;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_w",
        "num_strata", num_strata);
      current_statement__ = 214;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_w",
        "max_int(prior_EX_tau_inter_Nc)",
        max_int(prior_EX_tau_inter_Nc, pstream__));
      current_statement__ = 215;
      context__.validate_dims("data initialization", "prior_EX_tau_inter_w",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(max_int(prior_EX_tau_inter_Nc, pstream__))});
      prior_EX_tau_inter_w = std::vector<Eigen::Matrix<double,-1,1>>(num_strata,
                               Eigen::Matrix<double,-1,1>::Constant(max_int(
                                                                    prior_EX_tau_inter_Nc,
                                                                    pstream__),
                                 std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> prior_EX_tau_inter_w_flat__;
        current_statement__ = 215;
        prior_EX_tau_inter_w_flat__ = context__.vals_r("prior_EX_tau_inter_w");
        current_statement__ = 215;
        pos__ = 1;
        current_statement__ = 215;
        for (int sym1__ = 1; sym1__ <=
             max_int(prior_EX_tau_inter_Nc, pstream__); ++sym1__) {
          current_statement__ = 215;
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            current_statement__ = 215;
            stan::model::assign(prior_EX_tau_inter_w,
              prior_EX_tau_inter_w_flat__[(pos__ - 1)],
              "assigning variable prior_EX_tau_inter_w",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 215;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 216;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_m",
        "num_strata", num_strata);
      current_statement__ = 217;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_m",
        "max_int(prior_EX_tau_inter_Nc)",
        max_int(prior_EX_tau_inter_Nc, pstream__));
      current_statement__ = 218;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_m",
        "num_inter", num_inter);
      current_statement__ = 219;
      context__.validate_dims("data initialization", "prior_EX_tau_inter_m",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(max_int(prior_EX_tau_inter_Nc, pstream__)),
          static_cast<size_t>(num_inter)});
      prior_EX_tau_inter_m = std::vector<
                               std::vector<Eigen::Matrix<double,-1,1>>>(num_strata,
                               std::vector<Eigen::Matrix<double,-1,1>>(
                                 max_int(prior_EX_tau_inter_Nc, pstream__),
                                 Eigen::Matrix<double,-1,1>::Constant(num_inter,
                                   std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> prior_EX_tau_inter_m_flat__;
        current_statement__ = 219;
        prior_EX_tau_inter_m_flat__ = context__.vals_r("prior_EX_tau_inter_m");
        current_statement__ = 219;
        pos__ = 1;
        current_statement__ = 219;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 219;
          for (int sym2__ = 1; sym2__ <=
               max_int(prior_EX_tau_inter_Nc, pstream__); ++sym2__) {
            current_statement__ = 219;
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              current_statement__ = 219;
              stan::model::assign(prior_EX_tau_inter_m,
                prior_EX_tau_inter_m_flat__[(pos__ - 1)],
                "assigning variable prior_EX_tau_inter_m",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 219;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 220;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_sigma",
        "num_strata", num_strata);
      current_statement__ = 221;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_sigma",
        "max_int(prior_EX_tau_inter_Nc)",
        max_int(prior_EX_tau_inter_Nc, pstream__));
      current_statement__ = 222;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_sigma",
        "num_inter", num_inter);
      current_statement__ = 223;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_sigma",
        "num_inter", num_inter);
      current_statement__ = 224;
      context__.validate_dims("data initialization",
        "prior_EX_tau_inter_sigma", "double",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(max_int(prior_EX_tau_inter_Nc, pstream__)),
          static_cast<size_t>(num_inter), static_cast<size_t>(num_inter)});
      prior_EX_tau_inter_sigma = std::vector<
                                   std::vector<Eigen::Matrix<double,-1,-1>>>(num_strata,
                                   std::vector<Eigen::Matrix<double,-1,-1>>(
                                     max_int(prior_EX_tau_inter_Nc, pstream__),
                                     Eigen::Matrix<double,-1,-1>::Constant(num_inter,
                                       num_inter,
                                       std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> prior_EX_tau_inter_sigma_flat__;
        current_statement__ = 224;
        prior_EX_tau_inter_sigma_flat__ = context__.vals_r("prior_EX_tau_inter_sigma");
        current_statement__ = 224;
        pos__ = 1;
        current_statement__ = 224;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 224;
          for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
            current_statement__ = 224;
            for (int sym3__ = 1; sym3__ <=
                 max_int(prior_EX_tau_inter_Nc, pstream__); ++sym3__) {
              current_statement__ = 224;
              for (int sym4__ = 1; sym4__ <= num_strata; ++sym4__) {
                current_statement__ = 224;
                stan::model::assign(prior_EX_tau_inter_sigma,
                  prior_EX_tau_inter_sigma_flat__[(pos__ - 1)],
                  "assigning variable prior_EX_tau_inter_sigma",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                current_statement__ = 224;
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 225;
      context__.validate_dims("data initialization",
        "prior_EX_corr_eta_inter", "double", std::vector<size_t>{});
      prior_EX_corr_eta_inter = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 225;
      prior_EX_corr_eta_inter = context__.vals_r("prior_EX_corr_eta_inter")[(1
        - 1)];
      current_statement__ = 225;
      stan::math::check_greater_or_equal(function__,
        "prior_EX_corr_eta_inter", prior_EX_corr_eta_inter, 0);
      current_statement__ = 226;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_Nc",
        "num_comp", num_comp);
      current_statement__ = 227;
      context__.validate_dims("data initialization", "prior_NEX_mu_comp_Nc",
        "int", std::vector<size_t>{static_cast<size_t>(num_comp)});
      prior_NEX_mu_comp_Nc = std::vector<int>(num_comp,
                               std::numeric_limits<int>::min());
      current_statement__ = 227;
      prior_NEX_mu_comp_Nc = context__.vals_i("prior_NEX_mu_comp_Nc");
      current_statement__ = 228;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_w",
        "num_comp", num_comp);
      current_statement__ = 229;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_w",
        "max_int(prior_NEX_mu_comp_Nc)",
        max_int(prior_NEX_mu_comp_Nc, pstream__));
      current_statement__ = 230;
      context__.validate_dims("data initialization", "prior_NEX_mu_comp_w",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(max_int(prior_NEX_mu_comp_Nc, pstream__))});
      prior_NEX_mu_comp_w = std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
                              Eigen::Matrix<double,-1,1>::Constant(max_int(
                                                                    prior_NEX_mu_comp_Nc,
                                                                    pstream__),
                                std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> prior_NEX_mu_comp_w_flat__;
        current_statement__ = 230;
        prior_NEX_mu_comp_w_flat__ = context__.vals_r("prior_NEX_mu_comp_w");
        current_statement__ = 230;
        pos__ = 1;
        current_statement__ = 230;
        for (int sym1__ = 1; sym1__ <=
             max_int(prior_NEX_mu_comp_Nc, pstream__); ++sym1__) {
          current_statement__ = 230;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 230;
            stan::model::assign(prior_NEX_mu_comp_w,
              prior_NEX_mu_comp_w_flat__[(pos__ - 1)],
              "assigning variable prior_NEX_mu_comp_w",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 230;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 231;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_m",
        "num_comp", num_comp);
      current_statement__ = 232;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_m",
        "max_int(prior_NEX_mu_comp_Nc)",
        max_int(prior_NEX_mu_comp_Nc, pstream__));
      current_statement__ = 233;
      context__.validate_dims("data initialization", "prior_NEX_mu_comp_m",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(max_int(prior_NEX_mu_comp_Nc, pstream__)),
          static_cast<size_t>(2)});
      prior_NEX_mu_comp_m = std::vector<
                              std::vector<Eigen::Matrix<double,-1,1>>>(num_comp,
                              std::vector<Eigen::Matrix<double,-1,1>>(
                                max_int(prior_NEX_mu_comp_Nc, pstream__),
                                Eigen::Matrix<double,-1,1>::Constant(2,
                                  std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> prior_NEX_mu_comp_m_flat__;
        current_statement__ = 233;
        prior_NEX_mu_comp_m_flat__ = context__.vals_r("prior_NEX_mu_comp_m");
        current_statement__ = 233;
        pos__ = 1;
        current_statement__ = 233;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 233;
          for (int sym2__ = 1; sym2__ <=
               max_int(prior_NEX_mu_comp_Nc, pstream__); ++sym2__) {
            current_statement__ = 233;
            for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
              current_statement__ = 233;
              stan::model::assign(prior_NEX_mu_comp_m,
                prior_NEX_mu_comp_m_flat__[(pos__ - 1)],
                "assigning variable prior_NEX_mu_comp_m",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 233;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 234;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_sigma",
        "num_comp", num_comp);
      current_statement__ = 235;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_sigma",
        "max_int(prior_NEX_mu_comp_Nc)",
        max_int(prior_NEX_mu_comp_Nc, pstream__));
      current_statement__ = 236;
      context__.validate_dims("data initialization",
        "prior_NEX_mu_comp_sigma", "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(max_int(prior_NEX_mu_comp_Nc, pstream__)),
          static_cast<size_t>(2), static_cast<size_t>(2)});
      prior_NEX_mu_comp_sigma = std::vector<
                                  std::vector<Eigen::Matrix<double,-1,-1>>>(num_comp,
                                  std::vector<Eigen::Matrix<double,-1,-1>>(
                                    max_int(prior_NEX_mu_comp_Nc, pstream__),
                                    Eigen::Matrix<double,-1,-1>::Constant(2,
                                      2,
                                      std::numeric_limits<double>::quiet_NaN())));
      {
        std::vector<local_scalar_t__> prior_NEX_mu_comp_sigma_flat__;
        current_statement__ = 236;
        prior_NEX_mu_comp_sigma_flat__ = context__.vals_r("prior_NEX_mu_comp_sigma");
        current_statement__ = 236;
        pos__ = 1;
        current_statement__ = 236;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 236;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 236;
            for (int sym3__ = 1; sym3__ <=
                 max_int(prior_NEX_mu_comp_Nc, pstream__); ++sym3__) {
              current_statement__ = 236;
              for (int sym4__ = 1; sym4__ <= num_comp; ++sym4__) {
                current_statement__ = 236;
                stan::model::assign(prior_NEX_mu_comp_sigma,
                  prior_NEX_mu_comp_sigma_flat__[(pos__ - 1)],
                  "assigning variable prior_NEX_mu_comp_sigma",
                  stan::model::index_uni(sym4__),
                  stan::model::index_uni(sym3__),
                  stan::model::index_uni(sym2__),
                  stan::model::index_uni(sym1__));
                current_statement__ = 236;
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 237;
      context__.validate_dims("data initialization", "prior_NEX_mu_inter_Nc",
        "int", std::vector<size_t>{});
      prior_NEX_mu_inter_Nc = std::numeric_limits<int>::min();
      current_statement__ = 237;
      prior_NEX_mu_inter_Nc = context__.vals_i("prior_NEX_mu_inter_Nc")[(1 -
        1)];
      current_statement__ = 238;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_w",
        "prior_NEX_mu_inter_Nc", prior_NEX_mu_inter_Nc);
      current_statement__ = 239;
      context__.validate_dims("data initialization", "prior_NEX_mu_inter_w",
        "double",
        std::vector<size_t>{static_cast<size_t>(prior_NEX_mu_inter_Nc)});
      prior_NEX_mu_inter_w_data__ = Eigen::Matrix<double,-1,1>::Constant(prior_NEX_mu_inter_Nc,
                                      std::numeric_limits<double>::quiet_NaN());
      new (&prior_NEX_mu_inter_w)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(prior_NEX_mu_inter_w_data__.data(),
        prior_NEX_mu_inter_Nc);
      {
        std::vector<local_scalar_t__> prior_NEX_mu_inter_w_flat__;
        current_statement__ = 239;
        prior_NEX_mu_inter_w_flat__ = context__.vals_r("prior_NEX_mu_inter_w");
        current_statement__ = 239;
        pos__ = 1;
        current_statement__ = 239;
        for (int sym1__ = 1; sym1__ <= prior_NEX_mu_inter_Nc; ++sym1__) {
          current_statement__ = 239;
          stan::model::assign(prior_NEX_mu_inter_w,
            prior_NEX_mu_inter_w_flat__[(pos__ - 1)],
            "assigning variable prior_NEX_mu_inter_w",
            stan::model::index_uni(sym1__));
          current_statement__ = 239;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 240;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_m",
        "prior_NEX_mu_inter_Nc", prior_NEX_mu_inter_Nc);
      current_statement__ = 241;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_m",
        "num_inter", num_inter);
      current_statement__ = 242;
      context__.validate_dims("data initialization", "prior_NEX_mu_inter_m",
        "double",
        std::vector<size_t>{static_cast<size_t>(prior_NEX_mu_inter_Nc),
          static_cast<size_t>(num_inter)});
      prior_NEX_mu_inter_m = std::vector<Eigen::Matrix<double,-1,1>>(prior_NEX_mu_inter_Nc,
                               Eigen::Matrix<double,-1,1>::Constant(num_inter,
                                 std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> prior_NEX_mu_inter_m_flat__;
        current_statement__ = 242;
        prior_NEX_mu_inter_m_flat__ = context__.vals_r("prior_NEX_mu_inter_m");
        current_statement__ = 242;
        pos__ = 1;
        current_statement__ = 242;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 242;
          for (int sym2__ = 1; sym2__ <= prior_NEX_mu_inter_Nc; ++sym2__) {
            current_statement__ = 242;
            stan::model::assign(prior_NEX_mu_inter_m,
              prior_NEX_mu_inter_m_flat__[(pos__ - 1)],
              "assigning variable prior_NEX_mu_inter_m",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 242;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 243;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_sigma",
        "prior_NEX_mu_inter_Nc", prior_NEX_mu_inter_Nc);
      current_statement__ = 244;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_sigma",
        "num_inter", num_inter);
      current_statement__ = 245;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_sigma",
        "num_inter", num_inter);
      current_statement__ = 246;
      context__.validate_dims("data initialization",
        "prior_NEX_mu_inter_sigma", "double",
        std::vector<size_t>{static_cast<size_t>(prior_NEX_mu_inter_Nc),
          static_cast<size_t>(num_inter), static_cast<size_t>(num_inter)});
      prior_NEX_mu_inter_sigma = std::vector<Eigen::Matrix<double,-1,-1>>(prior_NEX_mu_inter_Nc,
                                   Eigen::Matrix<double,-1,-1>::Constant(num_inter,
                                     num_inter,
                                     std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> prior_NEX_mu_inter_sigma_flat__;
        current_statement__ = 246;
        prior_NEX_mu_inter_sigma_flat__ = context__.vals_r("prior_NEX_mu_inter_sigma");
        current_statement__ = 246;
        pos__ = 1;
        current_statement__ = 246;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 246;
          for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
            current_statement__ = 246;
            for (int sym3__ = 1; sym3__ <= prior_NEX_mu_inter_Nc; ++sym3__) {
              current_statement__ = 246;
              stan::model::assign(prior_NEX_mu_inter_sigma,
                prior_NEX_mu_inter_sigma_flat__[(pos__ - 1)],
                "assigning variable prior_NEX_mu_inter_sigma",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 246;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      current_statement__ = 247;
      context__.validate_dims("data initialization", "prior_tau_dist", "int",
        std::vector<size_t>{});
      prior_tau_dist = std::numeric_limits<int>::min();
      current_statement__ = 247;
      prior_tau_dist = context__.vals_i("prior_tau_dist")[(1 - 1)];
      current_statement__ = 247;
      stan::math::check_greater_or_equal(function__, "prior_tau_dist",
        prior_tau_dist, 0);
      current_statement__ = 247;
      stan::math::check_less_or_equal(function__, "prior_tau_dist",
        prior_tau_dist, 2);
      current_statement__ = 248;
      context__.validate_dims("data initialization", "prior_PD", "int",
        std::vector<size_t>{});
      prior_PD = std::numeric_limits<int>::min();
      current_statement__ = 248;
      prior_PD = context__.vals_i("prior_PD")[(1 - 1)];
      current_statement__ = 248;
      stan::math::check_greater_or_equal(function__, "prior_PD", prior_PD, 0);
      current_statement__ = 248;
      stan::math::check_less_or_equal(function__, "prior_PD", prior_PD, 1);
      current_statement__ = 249;
      stan::math::validate_non_negative_index("n", "num_obs", num_obs);
      current_statement__ = 250;
      n = std::vector<int>(num_obs, std::numeric_limits<int>::min());
      current_statement__ = 251;
      stan::math::validate_non_negative_index("finite_cov", "num_comp",
        num_comp);
      current_statement__ = 252;
      stan::math::validate_non_negative_index("finite_cov", "num_obs",
        num_obs);
      current_statement__ = 253;
      finite_cov = std::vector<std::vector<int>>(num_comp,
                     std::vector<int>(num_obs,
                       std::numeric_limits<int>::min()));
      current_statement__ = 254;
      num_EXNEX_comp = std::numeric_limits<int>::min();
      current_statement__ = 254;
      num_EXNEX_comp = stan::math::sum(prior_is_EXNEX_comp);
      current_statement__ = 255;
      num_EXNEX_inter = std::numeric_limits<int>::min();
      current_statement__ = 255;
      num_EXNEX_inter = stan::math::sum(prior_is_EXNEX_inter);
      current_statement__ = 256;
      num_mix_dim = std::numeric_limits<int>::min();
      current_statement__ = 256;
      num_mix_dim = (num_EXNEX_comp + num_EXNEX_inter);
      current_statement__ = 257;
      num_mix_comp = std::numeric_limits<int>::min();
      current_statement__ = 257;
      num_mix_comp = power_int(2, num_mix_dim, pstream__);
      current_statement__ = 258;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_sigma_L",
        "num_comp", num_comp);
      current_statement__ = 259;
      stan::math::validate_non_negative_index("prior_EX_mu_comp_sigma_L",
        "max_int(prior_EX_mu_comp_Nc)",
        max_int(prior_EX_mu_comp_Nc, pstream__));
      current_statement__ = 260;
      prior_EX_mu_comp_sigma_L = std::vector<
                                   std::vector<Eigen::Matrix<double,-1,-1>>>(num_comp,
                                   std::vector<Eigen::Matrix<double,-1,-1>>(
                                     max_int(prior_EX_mu_comp_Nc, pstream__),
                                     Eigen::Matrix<double,-1,-1>::Constant(2,
                                       2,
                                       std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 260;
      stan::model::assign(prior_EX_mu_comp_sigma_L,
        stan::math::rep_array(
          stan::math::diag_matrix(
            (Eigen::Matrix<double,-1,1>(2) << 1, 1).finished()), num_comp,
          max_int(prior_EX_mu_comp_Nc, pstream__)),
        "assigning variable prior_EX_mu_comp_sigma_L");
      current_statement__ = 261;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_sigma_L",
        "num_comp", num_comp);
      current_statement__ = 262;
      stan::math::validate_non_negative_index("prior_NEX_mu_comp_sigma_L",
        "max_int(prior_NEX_mu_comp_Nc)",
        max_int(prior_NEX_mu_comp_Nc, pstream__));
      current_statement__ = 263;
      prior_NEX_mu_comp_sigma_L = std::vector<
                                    std::vector<Eigen::Matrix<double,-1,-1>>>(num_comp,
                                    std::vector<Eigen::Matrix<double,-1,-1>>(
                                      max_int(prior_NEX_mu_comp_Nc, pstream__),
                                      Eigen::Matrix<double,-1,-1>::Constant(2,
                                        2,
                                        std::numeric_limits<double>::quiet_NaN(
                                          ))));
      current_statement__ = 263;
      stan::model::assign(prior_NEX_mu_comp_sigma_L,
        stan::math::rep_array(
          stan::math::diag_matrix(
            (Eigen::Matrix<double,-1,1>(2) << 1, 1).finished()), num_comp,
          max_int(prior_NEX_mu_comp_Nc, pstream__)),
        "assigning variable prior_NEX_mu_comp_sigma_L");
      current_statement__ = 264;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_sigma_L",
        "prior_EX_mu_inter_Nc", prior_EX_mu_inter_Nc);
      current_statement__ = 265;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_sigma_L",
        "num_inter", num_inter);
      current_statement__ = 266;
      stan::math::validate_non_negative_index("prior_EX_mu_inter_sigma_L",
        "num_inter", num_inter);
      current_statement__ = 267;
      prior_EX_mu_inter_sigma_L = std::vector<Eigen::Matrix<double,-1,-1>>(prior_EX_mu_inter_Nc,
                                    Eigen::Matrix<double,-1,-1>::Constant(num_inter,
                                      num_inter,
                                      std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 267;
      stan::model::assign(prior_EX_mu_inter_sigma_L,
        stan::math::rep_array(
          stan::math::diag_matrix(stan::math::rep_vector(1, num_inter)),
          prior_EX_mu_inter_Nc),
        "assigning variable prior_EX_mu_inter_sigma_L");
      current_statement__ = 268;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_sigma_L",
        "prior_NEX_mu_inter_Nc", prior_NEX_mu_inter_Nc);
      current_statement__ = 269;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_sigma_L",
        "num_inter", num_inter);
      current_statement__ = 270;
      stan::math::validate_non_negative_index("prior_NEX_mu_inter_sigma_L",
        "num_inter", num_inter);
      current_statement__ = 271;
      prior_NEX_mu_inter_sigma_L = std::vector<Eigen::Matrix<double,-1,-1>>(prior_NEX_mu_inter_Nc,
                                     Eigen::Matrix<double,-1,-1>::Constant(num_inter,
                                       num_inter,
                                       std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 271;
      stan::model::assign(prior_NEX_mu_inter_sigma_L,
        stan::math::rep_array(
          stan::math::diag_matrix(stan::math::rep_vector(1, num_inter)),
          prior_NEX_mu_inter_Nc),
        "assigning variable prior_NEX_mu_inter_sigma_L");
      current_statement__ = 272;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_sigma_L",
        "num_strata", num_strata);
      current_statement__ = 273;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_sigma_L",
        "num_comp", num_comp);
      current_statement__ = 274;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_sigma_L",
        "max_int(to_array_1d(prior_EX_tau_comp_Nc))",
        max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__));
      current_statement__ = 275;
      prior_EX_tau_comp_sigma_L = std::vector<
                                    std::vector<
                                      std::vector<
                                        Eigen::Matrix<double,-1,-1>>>>(num_strata,
                                    std::vector<
                                      std::vector<
                                        Eigen::Matrix<double,-1,-1>>>(num_comp,
                                      std::vector<
                                        Eigen::Matrix<double,-1,-1>>(
                                        max_int(
                                          stan::math::to_array_1d(
                                            prior_EX_tau_comp_Nc), pstream__),
                                        Eigen::Matrix<double,-1,-1>::Constant(2,
                                          2,
                                          std::numeric_limits<double>::quiet_NaN(
                                            )))));
      current_statement__ = 275;
      stan::model::assign(prior_EX_tau_comp_sigma_L,
        stan::math::rep_array(
          stan::math::diag_matrix(
            (Eigen::Matrix<double,-1,1>(2) << 1, 1).finished()), num_strata,
          num_comp,
          max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__)),
        "assigning variable prior_EX_tau_comp_sigma_L");
      current_statement__ = 276;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_sigma_L",
        "num_strata", num_strata);
      current_statement__ = 277;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_sigma_L",
        "max_int(prior_EX_tau_inter_Nc)",
        max_int(prior_EX_tau_inter_Nc, pstream__));
      current_statement__ = 278;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_sigma_L",
        "num_inter", num_inter);
      current_statement__ = 279;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_sigma_L",
        "num_inter", num_inter);
      current_statement__ = 280;
      prior_EX_tau_inter_sigma_L = std::vector<
                                     std::vector<Eigen::Matrix<double,-1,-1>>>(num_strata,
                                     std::vector<Eigen::Matrix<double,-1,-1>>(
                                       max_int(prior_EX_tau_inter_Nc,
                                         pstream__),
                                       Eigen::Matrix<double,-1,-1>::Constant(num_inter,
                                         num_inter,
                                         std::numeric_limits<double>::quiet_NaN(
                                           ))));
      current_statement__ = 280;
      stan::model::assign(prior_EX_tau_inter_sigma_L,
        stan::math::rep_array(
          stan::math::diag_matrix(stan::math::rep_vector(1, num_inter)),
          num_strata, max_int(prior_EX_tau_inter_Nc, pstream__)),
        "assigning variable prior_EX_tau_inter_sigma_L");
      current_statement__ = 281;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_mean",
        "num_strata", num_strata);
      current_statement__ = 282;
      stan::math::validate_non_negative_index("prior_EX_tau_comp_mean",
        "num_comp", num_comp);
      current_statement__ = 283;
      prior_EX_tau_comp_mean = std::vector<
                                 std::vector<Eigen::Matrix<double,-1,1>>>(num_strata,
                                 std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
                                   Eigen::Matrix<double,-1,1>::Constant(2,
                                     std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 283;
      stan::model::assign(prior_EX_tau_comp_mean,
        stan::math::rep_array(
          (Eigen::Matrix<double,-1,1>(2) << 0, 0).finished(), num_strata,
          num_comp), "assigning variable prior_EX_tau_comp_mean");
      current_statement__ = 284;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_mean",
        "num_strata", num_strata);
      current_statement__ = 285;
      stan::math::validate_non_negative_index("prior_EX_tau_inter_mean",
        "num_inter", num_inter);
      current_statement__ = 286;
      prior_EX_tau_inter_mean = std::vector<Eigen::Matrix<double,-1,1>>(num_strata,
                                  Eigen::Matrix<double,-1,1>::Constant(num_inter,
                                    std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 286;
      stan::model::assign(prior_EX_tau_inter_mean,
        stan::math::rep_array(stan::math::rep_vector(0, num_inter),
          num_strata), "assigning variable prior_EX_tau_inter_mean");
      current_statement__ = 299;
      for (int j = 1; j <= num_comp; ++j) {
        current_statement__ = 289;
        for (int k = 1; k <= max_int(prior_EX_mu_comp_Nc, pstream__); ++k) {
          current_statement__ = 287;
          stan::model::assign(prior_EX_mu_comp_sigma_L,
            block_cholesky_decompose(
              stan::model::rvalue(prior_EX_mu_comp_sigma,
                "prior_EX_mu_comp_sigma", stan::model::index_uni(j),
                stan::model::index_uni(k)), pstream__),
            "assigning variable prior_EX_mu_comp_sigma_L",
            stan::model::index_uni(j), stan::model::index_uni(k));
        }
        current_statement__ = 292;
        for (int k = 1; k <= max_int(prior_NEX_mu_comp_Nc, pstream__); ++k) {
          current_statement__ = 290;
          stan::model::assign(prior_NEX_mu_comp_sigma_L,
            block_cholesky_decompose(
              stan::model::rvalue(prior_NEX_mu_comp_sigma,
                "prior_NEX_mu_comp_sigma", stan::model::index_uni(j),
                stan::model::index_uni(k)), pstream__),
            "assigning variable prior_NEX_mu_comp_sigma_L",
            stan::model::index_uni(j), stan::model::index_uni(k));
        }
        current_statement__ = 297;
        for (int k = 1; k <=
             max_int(stan::math::to_array_1d(prior_EX_tau_comp_Nc), pstream__); ++k) {
          current_statement__ = 295;
          for (int s = 1; s <= num_strata; ++s) {
            current_statement__ = 293;
            stan::model::assign(prior_EX_tau_comp_sigma_L,
              block_cholesky_decompose(
                stan::model::rvalue(prior_EX_tau_comp_sigma,
                  "prior_EX_tau_comp_sigma", stan::model::index_uni(s),
                  stan::model::index_uni(j), stan::model::index_uni(k)),
                pstream__), "assigning variable prior_EX_tau_comp_sigma_L",
              stan::model::index_uni(s), stan::model::index_uni(j),
              stan::model::index_uni(k));
          }
        }
      }
      current_statement__ = 302;
      for (int k = 1; k <= prior_EX_mu_inter_Nc; ++k) {
        current_statement__ = 300;
        stan::model::assign(prior_EX_mu_inter_sigma_L,
          block_cholesky_decompose(
            stan::model::rvalue(prior_EX_mu_inter_sigma,
              "prior_EX_mu_inter_sigma", stan::model::index_uni(k)),
            pstream__), "assigning variable prior_EX_mu_inter_sigma_L",
          stan::model::index_uni(k));
      }
      current_statement__ = 305;
      for (int k = 1; k <= prior_NEX_mu_inter_Nc; ++k) {
        current_statement__ = 303;
        stan::model::assign(prior_NEX_mu_inter_sigma_L,
          block_cholesky_decompose(
            stan::model::rvalue(prior_NEX_mu_inter_sigma,
              "prior_NEX_mu_inter_sigma", stan::model::index_uni(k)),
            pstream__), "assigning variable prior_NEX_mu_inter_sigma_L",
          stan::model::index_uni(k));
      }
      current_statement__ = 310;
      for (int s = 1; s <= num_strata; ++s) {
        current_statement__ = 308;
        for (int k = 1; k <=
             max_int(stan::math::to_array_1d(prior_EX_tau_inter_Nc),
               pstream__); ++k) {
          current_statement__ = 306;
          stan::model::assign(prior_EX_tau_inter_sigma_L,
            block_cholesky_decompose(
              stan::model::rvalue(prior_EX_tau_inter_sigma,
                "prior_EX_tau_inter_sigma", stan::model::index_uni(s),
                stan::model::index_uni(k)), pstream__),
            "assigning variable prior_EX_tau_inter_sigma_L",
            stan::model::index_uni(s), stan::model::index_uni(k));
        }
      }
      current_statement__ = 320;
      for (int s = 1; s <= num_strata; ++s) {
        current_statement__ = 315;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 313;
          for (int k = 1; k <=
               stan::model::rvalue(prior_EX_tau_comp_Nc,
                 "prior_EX_tau_comp_Nc", stan::model::index_uni(s),
                 stan::model::index_uni(j)); ++k) {
            current_statement__ = 311;
            stan::model::assign(prior_EX_tau_comp_mean,
              stan::math::add(
                stan::model::deep_copy(
                  stan::model::rvalue(prior_EX_tau_comp_mean,
                    "prior_EX_tau_comp_mean", stan::model::index_uni(s),
                    stan::model::index_uni(j))),
                stan::math::multiply(
                  stan::model::rvalue(prior_EX_tau_comp_w,
                    "prior_EX_tau_comp_w", stan::model::index_uni(s),
                    stan::model::index_uni(j), stan::model::index_uni(k)),
                  stan::model::rvalue(prior_EX_tau_comp_m,
                    "prior_EX_tau_comp_m", stan::model::index_uni(s),
                    stan::model::index_uni(j), stan::model::index_uni(k)))),
              "assigning variable prior_EX_tau_comp_mean",
              stan::model::index_uni(s), stan::model::index_uni(j));
          }
        }
        current_statement__ = 318;
        for (int k = 1; k <=
             stan::model::rvalue(prior_EX_tau_inter_Nc,
               "prior_EX_tau_inter_Nc", stan::model::index_uni(s)); ++k) {
          current_statement__ = 316;
          stan::model::assign(prior_EX_tau_inter_mean,
            stan::math::add(
              stan::model::deep_copy(
                stan::model::rvalue(prior_EX_tau_inter_mean,
                  "prior_EX_tau_inter_mean", stan::model::index_uni(s))),
              stan::math::elt_multiply(
                stan::model::rvalue(prior_EX_tau_inter_w,
                  "prior_EX_tau_inter_w", stan::model::index_uni(s),
                  stan::model::index_uni(k)),
                stan::model::rvalue(prior_EX_tau_inter_m,
                  "prior_EX_tau_inter_m", stan::model::index_uni(s),
                  stan::model::index_uni(k)))),
            "assigning variable prior_EX_tau_inter_mean",
            stan::model::index_uni(s));
        }
      }
      current_statement__ = 321;
      stan::math::validate_non_negative_index("mix_is_EX_beta",
        "num_EXNEX_comp", num_EXNEX_comp);
      current_statement__ = 322;
      stan::math::validate_non_negative_index("mix_is_EX_beta",
        "num_mix_dim == 0 ? 0 : power_int(2, num_mix_dim - 1)",
        (stan::math::logical_eq(num_mix_dim, 0) ? 0 : power_int(2,
                                                        (num_mix_dim - 1),
                                                        pstream__)));
      current_statement__ = 323;
      mix_is_EX_beta = std::vector<std::vector<int>>(num_EXNEX_comp,
                         std::vector<int>((stan::math::logical_eq(
                                             num_mix_dim, 0) ? 0 : power_int(
                                                                    2,
                                                                    (num_mix_dim
                                                                    - 1),
                                                                    pstream__)),
                           std::numeric_limits<int>::min()));
      current_statement__ = 324;
      stan::math::validate_non_negative_index("mix_is_EX_eta",
        "num_EXNEX_inter", num_EXNEX_inter);
      current_statement__ = 325;
      stan::math::validate_non_negative_index("mix_is_EX_eta",
        "num_mix_dim == 0 ? 0 : power_int(2, num_mix_dim - 1)",
        (stan::math::logical_eq(num_mix_dim, 0) ? 0 : power_int(2,
                                                        (num_mix_dim - 1),
                                                        pstream__)));
      current_statement__ = 326;
      mix_is_EX_eta = std::vector<std::vector<int>>(num_EXNEX_inter,
                        std::vector<int>((stan::math::logical_eq(num_mix_dim,
                                            0) ? 0 : power_int(2,
                                                       (num_mix_dim - 1),
                                                       pstream__)),
                          std::numeric_limits<int>::min()));
      current_statement__ = 327;
      stan::math::validate_non_negative_index("mix_idx_beta", "num_mix_comp",
        num_mix_comp);
      current_statement__ = 328;
      stan::math::validate_non_negative_index("mix_idx_beta", "num_comp",
        num_comp);
      current_statement__ = 329;
      mix_idx_beta = std::vector<std::vector<int>>(num_mix_comp,
                       std::vector<int>(num_comp,
                         std::numeric_limits<int>::min()));
      current_statement__ = 330;
      stan::math::validate_non_negative_index("mix_idx_eta", "num_mix_comp",
        num_mix_comp);
      current_statement__ = 331;
      stan::math::validate_non_negative_index("mix_idx_eta", "num_inter",
        num_inter);
      current_statement__ = 332;
      mix_idx_eta = std::vector<std::vector<int>>(num_mix_comp,
                      std::vector<int>(num_inter,
                        std::numeric_limits<int>::min()));
      current_statement__ = 333;
      stan::math::validate_non_negative_index("num_obs_group", "num_groups",
        num_groups);
      current_statement__ = 334;
      num_obs_group = std::vector<int>(num_groups,
                        std::numeric_limits<int>::min());
      current_statement__ = 334;
      stan::model::assign(num_obs_group,
        count_elems(group, seq_int(1, num_groups, pstream__), pstream__),
        "assigning variable num_obs_group");
      current_statement__ = 335;
      stan::math::validate_non_negative_index("num_cases_group",
        "num_groups", num_groups);
      current_statement__ = 336;
      num_cases_group = std::vector<int>(num_groups,
                          std::numeric_limits<int>::min());
      current_statement__ = 336;
      stan::model::assign(num_cases_group,
        stan::math::rep_array(0, num_groups),
        "assigning variable num_cases_group");
      current_statement__ = 337;
      stan::math::validate_non_negative_index("group_obs_idx", "num_groups",
        num_groups);
      current_statement__ = 338;
      stan::math::validate_non_negative_index("group_obs_idx",
        "max(num_obs_group)", stan::math::max(num_obs_group));
      current_statement__ = 339;
      group_obs_idx = std::vector<std::vector<int>>(num_groups,
                        std::vector<int>(stan::math::max(num_obs_group),
                          std::numeric_limits<int>::min()));
      current_statement__ = 339;
      stan::model::assign(group_obs_idx,
        stan::math::rep_array(0, num_groups, stan::math::max(num_obs_group)),
        "assigning variable group_obs_idx");
      current_statement__ = 340;
      stan::math::validate_non_negative_index("mix_log_weight", "num_groups",
        num_groups);
      current_statement__ = 341;
      stan::math::validate_non_negative_index("mix_log_weight",
        "num_mix_comp", num_mix_comp);
      current_statement__ = 342;
      mix_log_weight = std::vector<Eigen::Matrix<double,-1,1>>(num_groups,
                         Eigen::Matrix<double,-1,1>::Constant(num_mix_comp,
                           std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 343;
      stan::math::validate_non_negative_index("log_normfactor_group",
        "num_groups", num_groups);
      current_statement__ = 344;
      log_normfactor_group_data__ = Eigen::Matrix<double,-1,1>::Constant(num_groups,
                                      std::numeric_limits<double>::quiet_NaN());
      new (&log_normfactor_group)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(log_normfactor_group_data__.data(),
        num_groups);
      current_statement__ = 344;
      stan::model::assign(log_normfactor_group,
        stan::math::rep_vector(0, num_groups),
        "assigning variable log_normfactor_group");
      current_statement__ = 353;
      for (int g = 1; g <= num_groups; ++g) {
        int i = std::numeric_limits<int>::min();
        current_statement__ = 345;
        i = 1;
        current_statement__ = 351;
        for (int o = 1; o <= num_obs; ++o) {
          current_statement__ = 349;
          if (stan::math::logical_eq(
                stan::model::rvalue(group, "group", stan::model::index_uni(o)),
                g)) {
            current_statement__ = 346;
            stan::model::assign(group_obs_idx, o,
              "assigning variable group_obs_idx", stan::model::index_uni(g),
              stan::model::index_uni(i));
            current_statement__ = 347;
            i = (i + 1);
          }
        }
      }
      current_statement__ = 361;
      for (int g = 1; g <= num_groups; ++g) {
        int group_size = std::numeric_limits<int>::min();
        current_statement__ = 354;
        group_size = stan::model::rvalue(num_obs_group, "num_obs_group",
                       stan::model::index_uni(g));
        current_statement__ = 355;
        stan::math::validate_non_negative_index("obs_gidx", "group_size",
          group_size);
        std::vector<int> obs_gidx =
          std::vector<int>(group_size, std::numeric_limits<int>::min());
        current_statement__ = 356;
        stan::model::assign(obs_gidx,
          stan::model::rvalue(group_obs_idx, "group_obs_idx",
            stan::model::index_uni(g),
            stan::model::index_min_max(1, group_size)),
          "assigning variable obs_gidx");
        current_statement__ = 359;
        if (stan::math::logical_gt(
              cardinality_int(
                stan::model::rvalue(stratum, "stratum",
                  stan::model::index_multi(obs_gidx)), pstream__), 1)) {
          current_statement__ = 357;
          std::stringstream errmsg_stream__;
          stan::math::stan_print(&errmsg_stream__, "Group ");
          stan::math::stan_print(&errmsg_stream__, g);
          stan::math::stan_print(&errmsg_stream__,
            " is assigned to multiple strata.");
          throw std::domain_error(errmsg_stream__.str());
        }
      }
      current_statement__ = 368;
      for (int j = 1; j <= num_comp; ++j) {
        current_statement__ = 362;
        stan::math::validate_non_negative_index("X_comp_intercept",
          "num_obs", num_obs);
        Eigen::Matrix<double,-1,1> X_comp_intercept =
          Eigen::Matrix<double,-1,1>::Constant(num_obs,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 363;
        stan::model::assign(X_comp_intercept,
          stan::model::rvalue(X_comp, "X_comp", stan::model::index_uni(j),
            stan::model::index_omni(), stan::model::index_uni(1)),
          "assigning variable X_comp_intercept");
        current_statement__ = 366;
        if ((stan::math::primitive_value(
               stan::math::logical_gt(
                 cardinality_vector(X_comp_intercept, pstream__), 1))
            ||
            stan::math::primitive_value(
              stan::math::logical_neq(
                stan::model::rvalue(X_comp, "X_comp",
                  stan::model::index_uni(j), stan::model::index_uni(1),
                  stan::model::index_uni(1)), 1.0)))) {
          current_statement__ = 364;
          std::stringstream errmsg_stream__;
          stan::math::stan_print(&errmsg_stream__, "Compound (");
          stan::math::stan_print(&errmsg_stream__, j);
          stan::math::stan_print(&errmsg_stream__,
            ") design matrix must have an intercept.");
          throw std::domain_error(errmsg_stream__.str());
        }
      }
      current_statement__ = 375;
      if (stan::math::logical_gt(num_inter, 0)) {
        current_statement__ = 369;
        stan::math::validate_non_negative_index("X_inter_intercept",
          "num_obs", num_obs);
        Eigen::Matrix<double,-1,1> X_inter_intercept =
          Eigen::Matrix<double,-1,1>::Constant(num_obs,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 370;
        stan::model::assign(X_inter_intercept,
          stan::model::rvalue(X_inter, "X_inter", stan::model::index_omni(),
            stan::model::index_uni(1)),
          "assigning variable X_inter_intercept");
        current_statement__ = 373;
        if ((stan::math::primitive_value(
               stan::math::logical_eq(
                 cardinality_vector(X_inter_intercept, pstream__), 1))
            &&
            stan::math::primitive_value(
              stan::math::logical_eq(
                stan::model::rvalue(X_inter, "X_inter",
                  stan::model::index_uni(1), stan::model::index_uni(1)), 1.0)))) {
          current_statement__ = 371;
          if (pstream__) {
            stan::math::stan_print(pstream__,
              "INFO: Interaction design matrix appears to have an intercept, which is unexpected.");
            *(pstream__) << std::endl;
          }
        }
      }
      current_statement__ = 379;
      for (int i = 1; i <= num_obs; ++i) {
        current_statement__ = 376;
        stan::model::assign(n,
          (stan::model::rvalue(r, "r", stan::model::index_uni(i)) +
          stan::model::rvalue(nr, "nr", stan::model::index_uni(i))),
          "assigning variable n", stan::model::index_uni(i));
        current_statement__ = 377;
        stan::model::assign(log_normfactor_group,
          (stan::model::rvalue(log_normfactor_group, "log_normfactor_group",
             stan::model::index_uni(
               stan::model::rvalue(group, "group", stan::model::index_uni(i))))
          +
          stan::math::binomial_coefficient_log(
            stan::model::rvalue(n, "n", stan::model::index_uni(i)),
            stan::model::rvalue(r, "r", stan::model::index_uni(i)))),
          "assigning variable log_normfactor_group",
          stan::model::index_uni(
            stan::model::rvalue(group, "group", stan::model::index_uni(i))));
      }
      current_statement__ = 385;
      for (int g = 1; g <= num_groups; ++g) {
        int group_size = std::numeric_limits<int>::min();
        current_statement__ = 380;
        group_size = stan::model::rvalue(num_obs_group, "num_obs_group",
                       stan::model::index_uni(g));
        current_statement__ = 381;
        stan::math::validate_non_negative_index("obs_gidx", "group_size",
          group_size);
        std::vector<int> obs_gidx =
          std::vector<int>(group_size, std::numeric_limits<int>::min());
        current_statement__ = 382;
        stan::model::assign(obs_gidx,
          stan::model::rvalue(group_obs_idx, "group_obs_idx",
            stan::model::index_uni(g),
            stan::model::index_min_max(1, group_size)),
          "assigning variable obs_gidx");
        current_statement__ = 383;
        stan::model::assign(num_cases_group,
          stan::math::sum(
            stan::model::rvalue(n, "n", stan::model::index_multi(obs_gidx))),
          "assigning variable num_cases_group", stan::model::index_uni(g));
      }
      {
        current_statement__ = 386;
        stan::math::validate_non_negative_index("finite_cov_sum", "num_obs",
          num_obs);
        std::vector<int> finite_cov_sum =
          std::vector<int>(num_obs, std::numeric_limits<int>::min());
        current_statement__ = 387;
        stan::model::assign(finite_cov_sum,
          stan::math::rep_array(0, num_obs),
          "assigning variable finite_cov_sum");
        current_statement__ = 393;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 391;
          for (int i = 1; i <= num_obs; ++i) {
            current_statement__ = 388;
            stan::model::assign(finite_cov,
              ((stan::math::primitive_value(
                  stan::math::logical_negation(
                    stan::math::is_inf(
                      stan::model::rvalue(X_comp, "X_comp",
                        stan::model::index_uni(j), stan::model::index_uni(i),
                        stan::model::index_uni(1))))) &&
              stan::math::primitive_value(
                stan::math::logical_negation(
                  stan::math::is_inf(
                    stan::model::rvalue(X_comp, "X_comp",
                      stan::model::index_uni(j), stan::model::index_uni(i),
                      stan::model::index_uni(2)))))) ? 1 : 0),
              "assigning variable finite_cov", stan::model::index_uni(j),
              stan::model::index_uni(i));
            current_statement__ = 389;
            stan::model::assign(finite_cov_sum,
              (stan::model::rvalue(finite_cov_sum, "finite_cov_sum",
                 stan::model::index_uni(i)) +
              stan::model::rvalue(finite_cov, "finite_cov",
                stan::model::index_uni(j), stan::model::index_uni(i))),
              "assigning variable finite_cov_sum", stan::model::index_uni(i));
          }
        }
        current_statement__ = 398;
        for (int i = 1; i <= num_obs; ++i) {
          current_statement__ = 396;
          if (stan::math::logical_eq(
                stan::model::rvalue(finite_cov_sum, "finite_cov_sum",
                  stan::model::index_uni(i)), 0)) {
            current_statement__ = 394;
            std::stringstream errmsg_stream__;
            stan::math::stan_print(&errmsg_stream__,
              "No finite covariates for observation ");
            stan::math::stan_print(&errmsg_stream__, i);
            throw std::domain_error(errmsg_stream__.str());
          }
        }
      }
      current_statement__ = 400;
      if (pstream__) {
        stan::math::stan_print(pstream__, "Number of groups: ");
        stan::math::stan_print(pstream__, num_groups);
        *(pstream__) << std::endl;
      }
      current_statement__ = 401;
      if (pstream__) {
        stan::math::stan_print(pstream__, "Number of strata: ");
        stan::math::stan_print(pstream__, num_strata);
        *(pstream__) << std::endl;
      }
      current_statement__ = 402;
      if (pstream__) {
        stan::math::stan_print(pstream__, "EXNEX enabled for compounds ");
        stan::math::stan_print(pstream__, num_EXNEX_comp);
        stan::math::stan_print(pstream__, "/");
        stan::math::stan_print(pstream__, num_comp);
        stan::math::stan_print(pstream__, ":    ");
        stan::math::stan_print(pstream__, prior_is_EXNEX_comp);
        *(pstream__) << std::endl;
      }
      current_statement__ = 403;
      if (pstream__) {
        stan::math::stan_print(pstream__, "EXNEX enabled for interactions ");
        stan::math::stan_print(pstream__, num_EXNEX_inter);
        stan::math::stan_print(pstream__, "/");
        stan::math::stan_print(pstream__, num_inter);
        stan::math::stan_print(pstream__, ": ");
        stan::math::stan_print(pstream__, prior_is_EXNEX_inter);
        *(pstream__) << std::endl;
      }
      current_statement__ = 404;
      if (pstream__) {
        stan::math::stan_print(pstream__, "EXNEX mixture dimensionality ");
        stan::math::stan_print(pstream__, num_mix_dim);
        stan::math::stan_print(pstream__, " leads to ");
        stan::math::stan_print(pstream__, num_mix_comp);
        stan::math::stan_print(pstream__, " combinations.");
        *(pstream__) << std::endl;
      }
      current_statement__ = 405;
      if (pstream__) {
        stan::math::stan_print(pstream__, "Observation => group assignment:");
        *(pstream__) << std::endl;
      }
      current_statement__ = 408;
      for (int g = 1; g <= num_groups; ++g) {
        current_statement__ = 406;
        if (pstream__) {
          stan::math::stan_print(pstream__, "Group ");
          stan::math::stan_print(pstream__, g);
          stan::math::stan_print(pstream__, ": ");
          stan::math::stan_print(pstream__,
            stan::model::rvalue(group_obs_idx, "group_obs_idx",
              stan::model::index_uni(g),
              stan::model::index_min_max(1,
                stan::model::rvalue(num_obs_group, "num_obs_group",
                  stan::model::index_uni(g)))));
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 409;
      if (pstream__) {
        stan::math::stan_print(pstream__, "");
        *(pstream__) << std::endl;
      }
      current_statement__ = 410;
      if (pstream__) {
        stan::math::stan_print(pstream__, "Group => stratum assignment:");
        *(pstream__) << std::endl;
      }
      current_statement__ = 413;
      for (int g = 1; g <= num_groups; ++g) {
        current_statement__ = 411;
        if (pstream__) {
          stan::math::stan_print(pstream__, g);
          stan::math::stan_print(pstream__, " => ");
          stan::math::stan_print(pstream__,
            stan::model::rvalue(group_stratum_cid, "group_stratum_cid",
              stan::model::index_uni(g)));
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 414;
      if (pstream__) {
        stan::math::stan_print(pstream__,
          "Prior distribution on tau parameters:");
        *(pstream__) << std::endl;
      }
      current_statement__ = 423;
      if (stan::math::logical_eq(prior_tau_dist, 0)) {
        current_statement__ = 421;
        if (pstream__) {
          stan::math::stan_print(pstream__, "Fixed");
          *(pstream__) << std::endl;
        }
      } else {
        current_statement__ = 420;
        if (stan::math::logical_eq(prior_tau_dist, 1)) {
          current_statement__ = 418;
          if (pstream__) {
            stan::math::stan_print(pstream__, "Log-Normal");
            *(pstream__) << std::endl;
          }
        } else {
          current_statement__ = 417;
          if (stan::math::logical_eq(prior_tau_dist, 2)) {
            current_statement__ = 415;
            if (pstream__) {
              stan::math::stan_print(pstream__, "Truncated Normal");
              *(pstream__) << std::endl;
            }
          }
        }
      }
      current_statement__ = 426;
      if (prior_PD) {
        current_statement__ = 424;
        if (pstream__) {
          stan::math::stan_print(pstream__,
            "Info: Sampling from prior predictive distribution.");
          *(pstream__) << std::endl;
        }
      }
      current_statement__ = 429;
      for (int g = 1; g <= num_groups; ++g) {
        current_statement__ = 427;
        stan::model::assign(mix_log_weight,
          stan::math::rep_vector(0.0, num_mix_comp),
          "assigning variable mix_log_weight", stan::model::index_uni(g));
      }
      current_statement__ = 472;
      for (int i = 1; i <= num_mix_comp; ++i) {
        current_statement__ = 430;
        stan::math::validate_non_negative_index("mix_ind_base",
          "num_mix_dim", num_mix_dim);
        std::vector<int> mix_ind_base =
          std::vector<int>(num_mix_dim, std::numeric_limits<int>::min());
        current_statement__ = 431;
        stan::model::assign(mix_ind_base,
          decimal2base((i - 1), num_mix_dim, 2, pstream__),
          "assigning variable mix_ind_base");
        current_statement__ = 432;
        stan::math::validate_non_negative_index("mix_ind",
          "num_comp + num_inter", (num_comp + num_inter));
        std::vector<int> mix_ind =
          std::vector<int>((num_comp + num_inter),
            std::numeric_limits<int>::min());
        current_statement__ = 436;
        for (int j = 1; j <= num_mix_dim; ++j) {
          current_statement__ = 434;
          stan::model::assign(mix_ind_base,
            (stan::model::rvalue(mix_ind_base, "mix_ind_base",
               stan::model::index_uni(j)) + 1),
            "assigning variable mix_ind_base", stan::model::index_uni(j));
        }
        {
          int k = std::numeric_limits<int>::min();
          current_statement__ = 437;
          k = 1;
          current_statement__ = 445;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 443;
            if (stan::model::rvalue(prior_is_EXNEX_comp,
                  "prior_is_EXNEX_comp", stan::model::index_uni(j))) {
              current_statement__ = 440;
              stan::model::assign(mix_ind,
                stan::model::rvalue(mix_ind_base, "mix_ind_base",
                  stan::model::index_uni(k)), "assigning variable mix_ind",
                stan::model::index_uni(j));
              current_statement__ = 441;
              k = (k + 1);
            } else {
              current_statement__ = 438;
              stan::model::assign(mix_ind, 1, "assigning variable mix_ind",
                stan::model::index_uni(j));
            }
          }
        }
        {
          int k = std::numeric_limits<int>::min();
          current_statement__ = 447;
          k = 1;
          current_statement__ = 455;
          for (int j = 1; j <= num_inter; ++j) {
            current_statement__ = 453;
            if (stan::model::rvalue(prior_is_EXNEX_inter,
                  "prior_is_EXNEX_inter", stan::model::index_uni(j))) {
              current_statement__ = 450;
              stan::model::assign(mix_ind,
                stan::model::rvalue(mix_ind_base, "mix_ind_base",
                  stan::model::index_uni((num_EXNEX_comp + k))),
                "assigning variable mix_ind",
                stan::model::index_uni((num_comp + j)));
              current_statement__ = 451;
              k = (k + 1);
            } else {
              current_statement__ = 448;
              stan::model::assign(mix_ind, 1, "assigning variable mix_ind",
                stan::model::index_uni((num_comp + j)));
            }
          }
        }
        current_statement__ = 470;
        for (int g = 1; g <= num_groups; ++g) {
          current_statement__ = 461;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 459;
            if (stan::model::rvalue(prior_is_EXNEX_comp,
                  "prior_is_EXNEX_comp", stan::model::index_uni(j))) {
              current_statement__ = 457;
              stan::model::assign(mix_log_weight,
                (stan::model::rvalue(mix_log_weight, "mix_log_weight",
                   stan::model::index_uni(g), stan::model::index_uni(i)) +
                (stan::math::logical_eq(
                   stan::model::rvalue(mix_ind, "mix_ind",
                     stan::model::index_uni(j)), 1) ? stan::math::log(
                                                        stan::model::rvalue(
                                                          prior_EX_prob_comp,
                                                          "prior_EX_prob_comp",
                                                          stan::model::index_uni(
                                                            g),
                                                          stan::model::index_uni(
                                                            j))) : stan::math::log1m(
                                                                    stan::model::rvalue(
                                                                    prior_EX_prob_comp,
                                                                    "prior_EX_prob_comp",
                                                                    stan::model::index_uni(
                                                                    g),
                                                                    stan::model::index_uni(
                                                                    j))))),
                "assigning variable mix_log_weight",
                stan::model::index_uni(g), stan::model::index_uni(i));
            }
          }
          current_statement__ = 466;
          for (int j = 1; j <= num_inter; ++j) {
            current_statement__ = 464;
            if (stan::model::rvalue(prior_is_EXNEX_inter,
                  "prior_is_EXNEX_inter", stan::model::index_uni(j))) {
              current_statement__ = 462;
              stan::model::assign(mix_log_weight,
                (stan::model::rvalue(mix_log_weight, "mix_log_weight",
                   stan::model::index_uni(g), stan::model::index_uni(i)) +
                (stan::math::logical_eq(
                   stan::model::rvalue(mix_ind, "mix_ind",
                     stan::model::index_uni((num_comp + j))), 1) ? stan::math::log(
                                                                    stan::model::rvalue(
                                                                    prior_EX_prob_inter,
                                                                    "prior_EX_prob_inter",
                                                                    stan::model::index_uni(
                                                                    g),
                                                                    stan::model::index_uni(
                                                                    j))) : 
                stan::math::log1m(
                  stan::model::rvalue(prior_EX_prob_inter,
                    "prior_EX_prob_inter", stan::model::index_uni(g),
                    stan::model::index_uni(j))))),
                "assigning variable mix_log_weight",
                stan::model::index_uni(g), stan::model::index_uni(i));
            }
          }
          current_statement__ = 467;
          stan::model::assign(mix_idx_beta,
            stan::model::rvalue(mix_ind, "mix_ind",
              stan::model::index_min_max(1, num_comp)),
            "assigning variable mix_idx_beta", stan::model::index_uni(i));
          current_statement__ = 468;
          stan::model::assign(mix_idx_eta,
            stan::model::rvalue(mix_ind, "mix_ind",
              stan::model::index_min_max((num_comp + 1), (num_comp +
                num_inter))), "assigning variable mix_idx_eta",
            stan::model::index_uni(i));
        }
      }
      {
        int i = std::numeric_limits<int>::min();
        current_statement__ = 473;
        i = 1;
        current_statement__ = 479;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 477;
          if (stan::model::rvalue(prior_is_EXNEX_comp, "prior_is_EXNEX_comp",
                stan::model::index_uni(j))) {
            current_statement__ = 474;
            stan::model::assign(mix_is_EX_beta,
              which_elem(
                stan::model::rvalue(mix_idx_beta, "mix_idx_beta",
                  stan::model::index_omni(), stan::model::index_uni(j)), 1,
                pstream__), "assigning variable mix_is_EX_beta",
              stan::model::index_uni(i));
            current_statement__ = 475;
            i = (i + 1);
          }
        }
      }
      {
        int i = std::numeric_limits<int>::min();
        current_statement__ = 481;
        i = 1;
        current_statement__ = 487;
        for (int j = 1; j <= num_inter; ++j) {
          current_statement__ = 485;
          if (stan::model::rvalue(prior_is_EXNEX_inter,
                "prior_is_EXNEX_inter", stan::model::index_uni(j))) {
            current_statement__ = 482;
            stan::model::assign(mix_is_EX_eta,
              which_elem(
                stan::model::rvalue(mix_idx_eta, "mix_idx_eta",
                  stan::model::index_omni(), stan::model::index_uni(j)), 1,
                pstream__), "assigning variable mix_is_EX_eta",
              stan::model::index_uni(i));
            current_statement__ = 483;
            i = (i + 1);
          }
        }
      }
      current_statement__ = 250;
      stan::math::check_greater_or_equal(function__, "n", n, 0);
      current_statement__ = 253;
      stan::math::check_greater_or_equal(function__, "finite_cov",
        finite_cov, 0);
      current_statement__ = 253;
      stan::math::check_less_or_equal(function__, "finite_cov", finite_cov, 1);
      current_statement__ = 254;
      stan::math::check_greater_or_equal(function__, "num_EXNEX_comp",
        num_EXNEX_comp, 0);
      current_statement__ = 254;
      stan::math::check_less_or_equal(function__, "num_EXNEX_comp",
        num_EXNEX_comp, num_comp);
      current_statement__ = 255;
      stan::math::check_greater_or_equal(function__, "num_EXNEX_inter",
        num_EXNEX_inter, 0);
      current_statement__ = 255;
      stan::math::check_less_or_equal(function__, "num_EXNEX_inter",
        num_EXNEX_inter, num_inter);
      current_statement__ = 256;
      stan::math::check_greater_or_equal(function__, "num_mix_dim",
        num_mix_dim, 0);
      current_statement__ = 257;
      stan::math::check_greater_or_equal(function__, "num_mix_comp",
        num_mix_comp, 0);
      current_statement__ = 323;
      stan::math::check_greater_or_equal(function__, "mix_is_EX_beta",
        mix_is_EX_beta, 1);
      current_statement__ = 323;
      stan::math::check_less_or_equal(function__, "mix_is_EX_beta",
        mix_is_EX_beta, num_mix_comp);
      current_statement__ = 326;
      stan::math::check_greater_or_equal(function__, "mix_is_EX_eta",
        mix_is_EX_eta, 1);
      current_statement__ = 326;
      stan::math::check_less_or_equal(function__, "mix_is_EX_eta",
        mix_is_EX_eta, num_mix_comp);
      current_statement__ = 329;
      stan::math::check_greater_or_equal(function__, "mix_idx_beta",
        mix_idx_beta, 1);
      current_statement__ = 329;
      stan::math::check_less_or_equal(function__, "mix_idx_beta",
        mix_idx_beta, 2);
      current_statement__ = 332;
      stan::math::check_greater_or_equal(function__, "mix_idx_eta",
        mix_idx_eta, 1);
      current_statement__ = 332;
      stan::math::check_less_or_equal(function__, "mix_idx_eta", mix_idx_eta,
        2);
      current_statement__ = 334;
      stan::math::check_greater_or_equal(function__, "num_obs_group",
        num_obs_group, 0);
      current_statement__ = 334;
      stan::math::check_less_or_equal(function__, "num_obs_group",
        num_obs_group, num_obs);
      current_statement__ = 336;
      stan::math::check_greater_or_equal(function__, "num_cases_group",
        num_cases_group, 0);
      current_statement__ = 339;
      stan::math::check_greater_or_equal(function__, "group_obs_idx",
        group_obs_idx, 0);
      current_statement__ = 339;
      stan::math::check_less_or_equal(function__, "group_obs_idx",
        group_obs_idx, num_obs);
      current_statement__ = 342;
      stan::math::check_less_or_equal(function__, "mix_log_weight",
        mix_log_weight, 0);
      current_statement__ = 489;
      log_beta_raw_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 489;
      log_beta_raw_1dim__ = (2 * num_groups);
      current_statement__ = 489;
      stan::math::validate_non_negative_index("log_beta_raw",
        "2 * num_groups", log_beta_raw_1dim__);
      current_statement__ = 490;
      stan::math::validate_non_negative_index("log_beta_raw", "num_comp",
        num_comp);
      current_statement__ = 491;
      eta_raw_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 491;
      eta_raw_1dim__ = (2 * num_groups);
      current_statement__ = 491;
      stan::math::validate_non_negative_index("eta_raw", "2 * num_groups",
        eta_raw_1dim__);
      current_statement__ = 492;
      stan::math::validate_non_negative_index("eta_raw", "num_inter",
        num_inter);
      current_statement__ = 493;
      stan::math::validate_non_negative_index("mu_log_beta", "num_comp",
        num_comp);
      current_statement__ = 494;
      stan::math::validate_non_negative_index("tau_log_beta_raw",
        "num_strata", num_strata);
      current_statement__ = 495;
      stan::math::validate_non_negative_index("tau_log_beta_raw", "num_comp",
        num_comp);
      current_statement__ = 496;
      stan::math::validate_non_negative_index("L_corr_log_beta", "num_comp",
        num_comp);
      current_statement__ = 497;
      stan::math::validate_non_negative_index("mu_eta", "num_inter",
        num_inter);
      current_statement__ = 498;
      stan::math::validate_non_negative_index("tau_eta_raw", "num_strata",
        num_strata);
      current_statement__ = 499;
      stan::math::validate_non_negative_index("tau_eta_raw", "num_inter",
        num_inter);
      current_statement__ = 500;
      stan::math::validate_non_negative_index("L_corr_eta", "num_inter",
        num_inter);
      current_statement__ = 500;
      stan::math::validate_non_negative_index("L_corr_eta", "num_inter",
        num_inter);
      current_statement__ = 501;
      beta_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 501;
      beta_1dim__ = (2 * num_groups);
      current_statement__ = 501;
      stan::math::validate_non_negative_index("beta", "2 * num_groups",
        beta_1dim__);
      current_statement__ = 502;
      stan::math::validate_non_negative_index("beta", "num_comp", num_comp);
      current_statement__ = 503;
      eta_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 503;
      eta_1dim__ = (2 * num_groups);
      current_statement__ = 503;
      stan::math::validate_non_negative_index("eta", "2 * num_groups",
        eta_1dim__);
      current_statement__ = 504;
      stan::math::validate_non_negative_index("eta", "num_inter", num_inter);
      current_statement__ = 505;
      stan::math::validate_non_negative_index("tau_log_beta", "num_strata",
        num_strata);
      current_statement__ = 506;
      stan::math::validate_non_negative_index("tau_log_beta", "num_comp",
        num_comp);
      current_statement__ = 507;
      stan::math::validate_non_negative_index("tau_eta", "num_strata",
        num_strata);
      current_statement__ = 508;
      stan::math::validate_non_negative_index("tau_eta", "num_inter",
        num_inter);
      current_statement__ = 509;
      stan::math::validate_non_negative_index("beta_EX_prob", "num_groups",
        num_groups);
      current_statement__ = 510;
      stan::math::validate_non_negative_index("beta_EX_prob", "num_comp",
        num_comp);
      current_statement__ = 511;
      stan::math::validate_non_negative_index("eta_EX_prob", "num_groups",
        num_groups);
      current_statement__ = 512;
      stan::math::validate_non_negative_index("eta_EX_prob", "num_inter",
        num_inter);
      current_statement__ = 513;
      stan::math::validate_non_negative_index("beta_group", "num_groups",
        num_groups);
      current_statement__ = 514;
      stan::math::validate_non_negative_index("beta_group", "num_comp",
        num_comp);
      current_statement__ = 515;
      stan::math::validate_non_negative_index("eta_group", "num_groups",
        num_groups);
      current_statement__ = 516;
      stan::math::validate_non_negative_index("eta_group", "num_inter",
        num_inter);
      current_statement__ = 517;
      stan::math::validate_non_negative_index("log_lik_group", "num_groups",
        num_groups);
      current_statement__ = 518;
      stan::math::validate_non_negative_index("rho_log_beta", "num_comp",
        num_comp);
      current_statement__ = 519;
      stan::math::validate_non_negative_index("Sigma_corr_eta", "num_inter",
        num_inter);
      current_statement__ = 520;
      stan::math::validate_non_negative_index("Sigma_corr_eta", "num_inter",
        num_inter);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = (log_beta_raw_1dim__ * num_comp * 2) + (eta_raw_1dim__ *
      num_inter) + (num_comp * 2) + (num_strata * num_comp * 2) + (num_comp *
      ((2 * (2 - 1)) / 2)) + num_inter + (num_strata * num_inter) +
      ((num_inter * (num_inter - 1)) / 2);
  }
  inline std::string model_name() const final {
    return "model_blrm_exnex";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
             "stancflags = --allow-undefined"};
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "model_blrm_exnex_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>
        log_beta_raw =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(log_beta_raw_1dim__,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__)));
      current_statement__ = 1;
      log_beta_raw = in__.template read<
                       std::vector<
                         std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(log_beta_raw_1dim__,
                       num_comp, 2);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> eta_raw =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(eta_raw_1dim__,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
            DUMMY_VAR__));
      current_statement__ = 2;
      eta_raw = in__.template read<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(eta_raw_1dim__,
                  num_inter);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> mu_log_beta =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
      current_statement__ = 3;
      mu_log_beta = in__.template read<
                      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_comp,
                      2);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>
        tau_log_beta_raw =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_strata,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__)));
      current_statement__ = 4;
      tau_log_beta_raw = in__.template read_constrain_lb<
                           std::vector<
                             std::vector<
                               Eigen::Matrix<local_scalar_t__,-1,1>>>,
                           jacobian__>(0, lp__, num_strata, num_comp, 2);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> L_corr_log_beta =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(num_comp,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      current_statement__ = 5;
      L_corr_log_beta = in__.template read_constrain_cholesky_factor_corr<
                          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
                          jacobian__>(lp__, num_comp, 2);
      Eigen::Matrix<local_scalar_t__,-1,1> mu_eta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
          DUMMY_VAR__);
      current_statement__ = 6;
      mu_eta = in__.template read<
                 Eigen::Matrix<local_scalar_t__,-1,1>>(num_inter);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tau_eta_raw =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_strata,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
            DUMMY_VAR__));
      current_statement__ = 7;
      tau_eta_raw = in__.template read_constrain_lb<
                      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
                      jacobian__>(0, lp__, num_strata, num_inter);
      Eigen::Matrix<local_scalar_t__,-1,-1> L_corr_eta =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(num_inter, num_inter,
          DUMMY_VAR__);
      current_statement__ = 8;
      L_corr_eta = in__.template read_constrain_cholesky_factor_corr<
                     Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__,
                     num_inter);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>> beta =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(beta_1dim__,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> eta =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(eta_1dim__,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
            DUMMY_VAR__));
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>
        tau_log_beta =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_strata,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__)));
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tau_eta =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_strata,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
            DUMMY_VAR__));
      current_statement__ = 26;
      if (stan::math::logical_eq(prior_tau_dist, 0)) {
        current_statement__ = 23;
        stan::model::assign(tau_log_beta, prior_EX_tau_comp_mean,
          "assigning variable tau_log_beta");
        current_statement__ = 24;
        stan::model::assign(tau_eta, prior_EX_tau_inter_mean,
          "assigning variable tau_eta");
      } else {
        current_statement__ = 20;
        stan::model::assign(tau_log_beta, tau_log_beta_raw,
          "assigning variable tau_log_beta");
        current_statement__ = 21;
        stan::model::assign(tau_eta, tau_eta_raw,
          "assigning variable tau_eta");
      }
      current_statement__ = 35;
      for (int g = 1; g <= num_groups; ++g) {
        int s = std::numeric_limits<int>::min();
        current_statement__ = 27;
        s = stan::model::rvalue(group_stratum_cid, "group_stratum_cid",
              stan::model::index_uni(g));
        current_statement__ = 30;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 28;
          stan::model::assign(beta,
            stan::math::add(
              stan::model::rvalue(mu_log_beta, "mu_log_beta",
                stan::model::index_uni(j)),
              stan::math::multiply(
                stan::math::diag_pre_multiply(
                  stan::model::rvalue(tau_log_beta, "tau_log_beta",
                    stan::model::index_uni(s), stan::model::index_uni(j)),
                  stan::model::rvalue(L_corr_log_beta, "L_corr_log_beta",
                    stan::model::index_uni(j))),
                stan::model::rvalue(log_beta_raw, "log_beta_raw",
                  stan::model::index_uni(g), stan::model::index_uni(j)))),
            "assigning variable beta", stan::model::index_uni(g),
            stan::model::index_uni(j));
        }
        current_statement__ = 33;
        if (stan::math::logical_gt(num_inter, 0)) {
          current_statement__ = 31;
          stan::model::assign(eta,
            stan::math::add(mu_eta,
              stan::math::multiply(
                stan::math::diag_pre_multiply(
                  stan::model::rvalue(tau_eta, "tau_eta",
                    stan::model::index_uni(s)), L_corr_eta),
                stan::model::rvalue(eta_raw, "eta_raw",
                  stan::model::index_uni(g)))), "assigning variable eta",
            stan::model::index_uni(g));
        }
      }
      current_statement__ = 36;
      stan::model::assign(beta,
        stan::model::rvalue(log_beta_raw, "log_beta_raw",
          stan::model::index_min_max((num_groups + 1), (2 * num_groups))),
        "assigning variable beta",
        stan::model::index_min_max((num_groups + 1), (2 * num_groups)));
      current_statement__ = 37;
      stan::model::assign(eta,
        stan::model::rvalue(eta_raw, "eta_raw",
          stan::model::index_min_max((num_groups + 1), (2 * num_groups))),
        "assigning variable eta",
        stan::model::index_min_max((num_groups + 1), (2 * num_groups)));
      current_statement__ = 42;
      for (int g = 1; g <= (2 * num_groups); ++g) {
        current_statement__ = 40;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 38;
          stan::model::assign(beta,
            stan::math::exp(
              stan::model::rvalue(beta, "beta", stan::model::index_uni(g),
                stan::model::index_uni(j), stan::model::index_uni(2))),
            "assigning variable beta", stan::model::index_uni(g),
            stan::model::index_uni(j), stan::model::index_uni(2));
        }
      }
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "tau_log_beta",
        tau_log_beta, 0);
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "tau_eta", tau_eta, 0);
      {
        current_statement__ = 115;
        if (stan::math::logical_negation(prior_PD)) {
          current_statement__ = 113;
          if (stan::math::logical_eq(num_mix_comp, 1)) {
            current_statement__ = 102;
            stan::math::validate_non_negative_index("theta", "num_obs",
              num_obs);
            Eigen::Matrix<local_scalar_t__,-1,1> theta =
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_obs,
                DUMMY_VAR__);
            current_statement__ = 110;
            for (int g = 1; g <= num_groups; ++g) {
              int s = std::numeric_limits<int>::min();
              current_statement__ = 104;
              s = stan::model::rvalue(group_stratum_cid, "group_stratum_cid",
                    stan::model::index_uni(g));
              int group_size = std::numeric_limits<int>::min();
              current_statement__ = 105;
              group_size = stan::model::rvalue(num_obs_group,
                             "num_obs_group", stan::model::index_uni(g));
              current_statement__ = 106;
              stan::math::validate_non_negative_index("obs_gidx",
                "group_size", group_size);
              std::vector<int> obs_gidx =
                std::vector<int>(group_size, std::numeric_limits<int>::min());
              current_statement__ = 107;
              stan::model::assign(obs_gidx,
                stan::model::rvalue(group_obs_idx, "group_obs_idx",
                  stan::model::index_uni(g),
                  stan::model::index_min_max(1, group_size)),
                "assigning variable obs_gidx");
              current_statement__ = 108;
              stan::model::assign(theta,
                blrm_logit_fast(obs_gidx, n, X_comp, finite_cov, X_inter,
                  stan::model::rvalue(beta, "beta", stan::model::index_uni(g)),
                  stan::model::rvalue(eta, "eta", stan::model::index_uni(g)),
                  pstream__), "assigning variable theta",
                stan::model::index_multi(obs_gidx));
            }
            current_statement__ = 111;
            lp_accum__.add(stan::math::binomial_logit_lpmf<propto__>(r, n,
                             theta));
          } else {
            current_statement__ = 85;
            stan::math::validate_non_negative_index("log_lik", "num_groups",
              num_groups);
            Eigen::Matrix<local_scalar_t__,-1,1> log_lik =
              Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_groups,
                DUMMY_VAR__);
            current_statement__ = 99;
            for (int g = 1; g <= num_groups; ++g) {
              int s = std::numeric_limits<int>::min();
              current_statement__ = 87;
              s = stan::model::rvalue(group_stratum_cid, "group_stratum_cid",
                    stan::model::index_uni(g));
              int group_size = std::numeric_limits<int>::min();
              current_statement__ = 88;
              group_size = stan::model::rvalue(num_obs_group,
                             "num_obs_group", stan::model::index_uni(g));
              current_statement__ = 89;
              stan::math::validate_non_negative_index("obs_gidx",
                "group_size", group_size);
              std::vector<int> obs_gidx =
                std::vector<int>(group_size, std::numeric_limits<int>::min());
              current_statement__ = 90;
              stan::model::assign(obs_gidx,
                stan::model::rvalue(group_obs_idx, "group_obs_idx",
                  stan::model::index_uni(g),
                  stan::model::index_min_max(1, group_size)),
                "assigning variable obs_gidx");
              current_statement__ = 97;
              if (stan::math::logical_neq(
                    stan::model::rvalue(num_cases_group, "num_cases_group",
                      stan::model::index_uni(g)), 0)) {
                current_statement__ = 93;
                stan::math::validate_non_negative_index("mix_ll",
                  "num_mix_comp", num_mix_comp);
                Eigen::Matrix<local_scalar_t__,-1,1> mix_ll =
                  Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_mix_comp,
                    DUMMY_VAR__);
                current_statement__ = 94;
                stan::model::assign(mix_ll,
                  stan::math::add(
                    blrm_mix_lupmf_comp(g, num_groups, obs_gidx, r, n,
                      X_comp, finite_cov, X_inter, beta, mix_idx_beta, eta,
                      mix_idx_eta, pstream__),
                    stan::model::rvalue(mix_log_weight, "mix_log_weight",
                      stan::model::index_uni(g))),
                  "assigning variable mix_ll");
                current_statement__ = 95;
                stan::model::assign(log_lik, stan::math::log_sum_exp(mix_ll),
                  "assigning variable log_lik", stan::model::index_uni(g));
              } else {
                current_statement__ = 91;
                stan::model::assign(log_lik, 0.0,
                  "assigning variable log_lik", stan::model::index_uni(g));
              }
            }
            current_statement__ = 100;
            lp_accum__.add(stan::math::sum(log_lik));
          }
        }
        current_statement__ = 122;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 116;
          lp_accum__.add(mixmvnorm_lpdf<propto__>(
                           stan::model::rvalue(mu_log_beta, "mu_log_beta",
                             stan::model::index_uni(j)),
                           stan::model::rvalue(prior_EX_mu_comp_Nc,
                             "prior_EX_mu_comp_Nc", stan::model::index_uni(j)),
                           stan::model::rvalue(prior_EX_mu_comp_w,
                             "prior_EX_mu_comp_w", stan::model::index_uni(j)),
                           stan::model::rvalue(prior_EX_mu_comp_m,
                             "prior_EX_mu_comp_m", stan::model::index_uni(j)),
                           stan::model::rvalue(prior_EX_mu_comp_sigma_L,
                             "prior_EX_mu_comp_sigma_L",
                             stan::model::index_uni(j)), pstream__));
          current_statement__ = 119;
          for (int s = 1; s <= num_strata; ++s) {
            current_statement__ = 117;
            lp_accum__.add(mixmv_tau_prior_lpdf<propto__>(
                             stan::model::rvalue(tau_log_beta_raw,
                               "tau_log_beta_raw", stan::model::index_uni(s),
                               stan::model::index_uni(j)), prior_tau_dist,
                             stan::model::rvalue(prior_EX_tau_comp_Nc,
                               "prior_EX_tau_comp_Nc",
                               stan::model::index_uni(s),
                               stan::model::index_uni(j)),
                             stan::model::rvalue(prior_EX_tau_comp_w,
                               "prior_EX_tau_comp_w",
                               stan::model::index_uni(s),
                               stan::model::index_uni(j)),
                             stan::model::rvalue(prior_EX_tau_comp_m,
                               "prior_EX_tau_comp_m",
                               stan::model::index_uni(s),
                               stan::model::index_uni(j)),
                             stan::model::rvalue(prior_EX_tau_comp_sigma_L,
                               "prior_EX_tau_comp_sigma_L",
                               stan::model::index_uni(s),
                               stan::model::index_uni(j)), pstream__));
          }
          current_statement__ = 120;
          lp_accum__.add(stan::math::lkj_corr_cholesky_lpdf<propto__>(
                           stan::model::rvalue(L_corr_log_beta,
                             "L_corr_log_beta", stan::model::index_uni(j)),
                           stan::model::rvalue(prior_EX_corr_eta_comp,
                             "prior_EX_corr_eta_comp",
                             stan::model::index_uni(j))));
        }
        current_statement__ = 123;
        lp_accum__.add(mixmvnorm_lpdf<propto__>(mu_eta, prior_EX_mu_inter_Nc,
                         prior_EX_mu_inter_w, prior_EX_mu_inter_m,
                         prior_EX_mu_inter_sigma_L, pstream__));
        current_statement__ = 126;
        for (int s = 1; s <= num_strata; ++s) {
          current_statement__ = 124;
          lp_accum__.add(mixmv_tau_prior_lpdf<propto__>(
                           stan::model::rvalue(tau_eta_raw, "tau_eta_raw",
                             stan::model::index_uni(s)), prior_tau_dist,
                           stan::model::rvalue(prior_EX_tau_inter_Nc,
                             "prior_EX_tau_inter_Nc",
                             stan::model::index_uni(s)),
                           stan::model::rvalue(prior_EX_tau_inter_w,
                             "prior_EX_tau_inter_w",
                             stan::model::index_uni(s)),
                           stan::model::rvalue(prior_EX_tau_inter_m,
                             "prior_EX_tau_inter_m",
                             stan::model::index_uni(s)),
                           stan::model::rvalue(prior_EX_tau_inter_sigma_L,
                             "prior_EX_tau_inter_sigma_L",
                             stan::model::index_uni(s)), pstream__));
        }
        current_statement__ = 129;
        if (stan::math::logical_gt(num_inter, 0)) {
          current_statement__ = 127;
          lp_accum__.add(stan::math::lkj_corr_cholesky_lpdf<propto__>(
                           L_corr_eta, prior_EX_corr_eta_inter));
        }
        current_statement__ = 135;
        for (int g = 1; g <= num_groups; ++g) {
          current_statement__ = 132;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 130;
            lp_accum__.add(stan::math::std_normal_lpdf<propto__>(
                             stan::model::rvalue(log_beta_raw,
                               "log_beta_raw", stan::model::index_uni(g),
                               stan::model::index_uni(j))));
          }
          current_statement__ = 133;
          lp_accum__.add(stan::math::std_normal_lpdf<propto__>(
                           stan::model::rvalue(eta_raw, "eta_raw",
                             stan::model::index_uni(g))));
        }
        current_statement__ = 141;
        for (int g = (num_groups + 1); g <= (2 * num_groups); ++g) {
          current_statement__ = 138;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 136;
            lp_accum__.add(mixmvnorm_lpdf<propto__>(
                             stan::model::rvalue(log_beta_raw,
                               "log_beta_raw", stan::model::index_uni(g),
                               stan::model::index_uni(j)),
                             stan::model::rvalue(prior_NEX_mu_comp_Nc,
                               "prior_NEX_mu_comp_Nc",
                               stan::model::index_uni(j)),
                             stan::model::rvalue(prior_NEX_mu_comp_w,
                               "prior_NEX_mu_comp_w",
                               stan::model::index_uni(j)),
                             stan::model::rvalue(prior_NEX_mu_comp_m,
                               "prior_NEX_mu_comp_m",
                               stan::model::index_uni(j)),
                             stan::model::rvalue(prior_NEX_mu_comp_sigma_L,
                               "prior_NEX_mu_comp_sigma_L",
                               stan::model::index_uni(j)), pstream__));
          }
          current_statement__ = 139;
          lp_accum__.add(mixmvnorm_lpdf<propto__>(
                           stan::model::rvalue(eta_raw, "eta_raw",
                             stan::model::index_uni(g)),
                           prior_NEX_mu_inter_Nc, prior_NEX_mu_inter_w,
                           prior_NEX_mu_inter_m, prior_NEX_mu_inter_sigma_L,
                           pstream__));
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    static constexpr const char* function__ =
      "model_blrm_exnex_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> log_beta_raw =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(log_beta_raw_1dim__,
          std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
            Eigen::Matrix<double,-1,1>::Constant(2,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 1;
      log_beta_raw = in__.template read<
                       std::vector<
                         std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>>(log_beta_raw_1dim__,
                       num_comp, 2);
      std::vector<Eigen::Matrix<double,-1,1>> eta_raw =
        std::vector<Eigen::Matrix<double,-1,1>>(eta_raw_1dim__,
          Eigen::Matrix<double,-1,1>::Constant(num_inter,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 2;
      eta_raw = in__.template read<
                  std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(eta_raw_1dim__,
                  num_inter);
      std::vector<Eigen::Matrix<double,-1,1>> mu_log_beta =
        std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
          Eigen::Matrix<double,-1,1>::Constant(2,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 3;
      mu_log_beta = in__.template read<
                      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_comp,
                      2);
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> tau_log_beta_raw =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(num_strata,
          std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
            Eigen::Matrix<double,-1,1>::Constant(2,
              std::numeric_limits<double>::quiet_NaN())));
      current_statement__ = 4;
      tau_log_beta_raw = in__.template read_constrain_lb<
                           std::vector<
                             std::vector<
                               Eigen::Matrix<local_scalar_t__,-1,1>>>,
                           jacobian__>(0, lp__, num_strata, num_comp, 2);
      std::vector<Eigen::Matrix<double,-1,-1>> L_corr_log_beta =
        std::vector<Eigen::Matrix<double,-1,-1>>(num_comp,
          Eigen::Matrix<double,-1,-1>::Constant(2, 2,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 5;
      L_corr_log_beta = in__.template read_constrain_cholesky_factor_corr<
                          std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>,
                          jacobian__>(lp__, num_comp, 2);
      Eigen::Matrix<double,-1,1> mu_eta =
        Eigen::Matrix<double,-1,1>::Constant(num_inter,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 6;
      mu_eta = in__.template read<
                 Eigen::Matrix<local_scalar_t__,-1,1>>(num_inter);
      std::vector<Eigen::Matrix<double,-1,1>> tau_eta_raw =
        std::vector<Eigen::Matrix<double,-1,1>>(num_strata,
          Eigen::Matrix<double,-1,1>::Constant(num_inter,
            std::numeric_limits<double>::quiet_NaN()));
      current_statement__ = 7;
      tau_eta_raw = in__.template read_constrain_lb<
                      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
                      jacobian__>(0, lp__, num_strata, num_inter);
      Eigen::Matrix<double,-1,-1> L_corr_eta =
        Eigen::Matrix<double,-1,-1>::Constant(num_inter, num_inter,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      L_corr_eta = in__.template read_constrain_cholesky_factor_corr<
                     Eigen::Matrix<local_scalar_t__,-1,-1>, jacobian__>(lp__,
                     num_inter);
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> beta =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(beta_1dim__,
          std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
            Eigen::Matrix<double,-1,1>::Constant(2,
              std::numeric_limits<double>::quiet_NaN())));
      std::vector<Eigen::Matrix<double,-1,1>> eta =
        std::vector<Eigen::Matrix<double,-1,1>>(eta_1dim__,
          Eigen::Matrix<double,-1,1>::Constant(num_inter,
            std::numeric_limits<double>::quiet_NaN()));
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> tau_log_beta =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(num_strata,
          std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
            Eigen::Matrix<double,-1,1>::Constant(2,
              std::numeric_limits<double>::quiet_NaN())));
      std::vector<Eigen::Matrix<double,-1,1>> tau_eta =
        std::vector<Eigen::Matrix<double,-1,1>>(num_strata,
          Eigen::Matrix<double,-1,1>::Constant(num_inter,
            std::numeric_limits<double>::quiet_NaN()));
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
            out__.write(log_beta_raw[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
              1)]);
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
          out__.write(eta_raw[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          out__.write(mu_log_beta[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
            out__.write(tau_log_beta_raw[(sym3__ - 1)][(sym2__ - 1)][(sym1__
              - 1)]);
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
            out__.write(stan::model::rvalue(L_corr_log_beta,
                          "L_corr_log_beta", stan::model::index_uni(sym3__),
                          stan::model::index_uni(sym2__),
                          stan::model::index_uni(sym1__)));
          }
        }
      }
      out__.write(mu_eta);
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
          out__.write(tau_eta_raw[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      out__.write(L_corr_eta);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 26;
      if (stan::math::logical_eq(prior_tau_dist, 0)) {
        current_statement__ = 23;
        stan::model::assign(tau_log_beta, prior_EX_tau_comp_mean,
          "assigning variable tau_log_beta");
        current_statement__ = 24;
        stan::model::assign(tau_eta, prior_EX_tau_inter_mean,
          "assigning variable tau_eta");
      } else {
        current_statement__ = 20;
        stan::model::assign(tau_log_beta, tau_log_beta_raw,
          "assigning variable tau_log_beta");
        current_statement__ = 21;
        stan::model::assign(tau_eta, tau_eta_raw,
          "assigning variable tau_eta");
      }
      current_statement__ = 35;
      for (int g = 1; g <= num_groups; ++g) {
        int s = std::numeric_limits<int>::min();
        current_statement__ = 27;
        s = stan::model::rvalue(group_stratum_cid, "group_stratum_cid",
              stan::model::index_uni(g));
        current_statement__ = 30;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 28;
          stan::model::assign(beta,
            stan::math::add(
              stan::model::rvalue(mu_log_beta, "mu_log_beta",
                stan::model::index_uni(j)),
              stan::math::multiply(
                stan::math::diag_pre_multiply(
                  stan::model::rvalue(tau_log_beta, "tau_log_beta",
                    stan::model::index_uni(s), stan::model::index_uni(j)),
                  stan::model::rvalue(L_corr_log_beta, "L_corr_log_beta",
                    stan::model::index_uni(j))),
                stan::model::rvalue(log_beta_raw, "log_beta_raw",
                  stan::model::index_uni(g), stan::model::index_uni(j)))),
            "assigning variable beta", stan::model::index_uni(g),
            stan::model::index_uni(j));
        }
        current_statement__ = 33;
        if (stan::math::logical_gt(num_inter, 0)) {
          current_statement__ = 31;
          stan::model::assign(eta,
            stan::math::add(mu_eta,
              stan::math::multiply(
                stan::math::diag_pre_multiply(
                  stan::model::rvalue(tau_eta, "tau_eta",
                    stan::model::index_uni(s)), L_corr_eta),
                stan::model::rvalue(eta_raw, "eta_raw",
                  stan::model::index_uni(g)))), "assigning variable eta",
            stan::model::index_uni(g));
        }
      }
      current_statement__ = 36;
      stan::model::assign(beta,
        stan::model::rvalue(log_beta_raw, "log_beta_raw",
          stan::model::index_min_max((num_groups + 1), (2 * num_groups))),
        "assigning variable beta",
        stan::model::index_min_max((num_groups + 1), (2 * num_groups)));
      current_statement__ = 37;
      stan::model::assign(eta,
        stan::model::rvalue(eta_raw, "eta_raw",
          stan::model::index_min_max((num_groups + 1), (2 * num_groups))),
        "assigning variable eta",
        stan::model::index_min_max((num_groups + 1), (2 * num_groups)));
      current_statement__ = 42;
      for (int g = 1; g <= (2 * num_groups); ++g) {
        current_statement__ = 40;
        for (int j = 1; j <= num_comp; ++j) {
          current_statement__ = 38;
          stan::model::assign(beta,
            stan::math::exp(
              stan::model::rvalue(beta, "beta", stan::model::index_uni(g),
                stan::model::index_uni(j), stan::model::index_uni(2))),
            "assigning variable beta", stan::model::index_uni(g),
            stan::model::index_uni(j), stan::model::index_uni(2));
        }
      }
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "tau_log_beta",
        tau_log_beta, 0);
      current_statement__ = 12;
      stan::math::check_greater_or_equal(function__, "tau_eta", tau_eta, 0);
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= beta_1dim__; ++sym3__) {
              out__.write(beta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
            }
          }
        }
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= eta_1dim__; ++sym2__) {
            out__.write(eta[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              out__.write(tau_log_beta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ -
                1)]);
            }
          }
        }
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            out__.write(tau_eta[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      Eigen::Matrix<double,-1,-1> beta_EX_prob =
        Eigen::Matrix<double,-1,-1>::Constant(num_groups, num_comp,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> eta_EX_prob =
        Eigen::Matrix<double,-1,-1>::Constant(num_groups, num_inter,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<std::vector<Eigen::Matrix<double,-1,1>>> beta_group =
        std::vector<std::vector<Eigen::Matrix<double,-1,1>>>(num_groups,
          std::vector<Eigen::Matrix<double,-1,1>>(num_comp,
            Eigen::Matrix<double,-1,1>::Constant(2,
              std::numeric_limits<double>::quiet_NaN())));
      std::vector<Eigen::Matrix<double,-1,1>> eta_group =
        std::vector<Eigen::Matrix<double,-1,1>>(num_groups,
          Eigen::Matrix<double,-1,1>::Constant(num_inter,
            std::numeric_limits<double>::quiet_NaN()));
      Eigen::Matrix<double,-1,1> log_lik_group =
        Eigen::Matrix<double,-1,1>::Constant(num_groups,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> rho_log_beta =
        Eigen::Matrix<double,-1,1>::Constant(num_comp,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> Sigma_corr_eta =
        Eigen::Matrix<double,-1,-1>::Constant(num_inter, num_inter,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 19;
      stan::model::assign(Sigma_corr_eta,
        stan::math::multiply_lower_tri_self_transpose(L_corr_eta),
        "assigning variable Sigma_corr_eta");
      current_statement__ = 46;
      for (int j = 1; j <= num_comp; ++j) {
        Eigen::Matrix<double,-1,-1> Sigma_corr_log_beta =
          Eigen::Matrix<double,-1,-1>::Constant(2, 2,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 43;
        stan::model::assign(Sigma_corr_log_beta,
          stan::math::multiply_lower_tri_self_transpose(
            stan::model::rvalue(L_corr_log_beta, "L_corr_log_beta",
              stan::model::index_uni(j))),
          "assigning variable Sigma_corr_log_beta");
        current_statement__ = 44;
        stan::model::assign(rho_log_beta,
          stan::model::rvalue(Sigma_corr_log_beta, "Sigma_corr_log_beta",
            stan::model::index_uni(2), stan::model::index_uni(1)),
          "assigning variable rho_log_beta", stan::model::index_uni(j));
      }
      current_statement__ = 84;
      for (int g = 1; g <= num_groups; ++g) {
        int group_size = std::numeric_limits<int>::min();
        current_statement__ = 47;
        group_size = stan::model::rvalue(num_obs_group, "num_obs_group",
                       stan::model::index_uni(g));
        current_statement__ = 48;
        stan::math::validate_non_negative_index("obs_gidx", "group_size",
          group_size);
        std::vector<int> obs_gidx =
          std::vector<int>(group_size, std::numeric_limits<int>::min());
        current_statement__ = 49;
        stan::model::assign(obs_gidx,
          stan::model::rvalue(group_obs_idx, "group_obs_idx",
            stan::model::index_uni(g),
            stan::model::index_min_max(1, group_size)),
          "assigning variable obs_gidx");
        current_statement__ = 50;
        stan::math::validate_non_negative_index("mix_ll", "num_mix_comp",
          num_mix_comp);
        Eigen::Matrix<double,-1,1> mix_ll =
          Eigen::Matrix<double,-1,1>::Constant(num_mix_comp,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 51;
        stan::model::assign(mix_ll,
          stan::math::add(
            (prior_PD ? stan::math::eval(
                          stan::math::rep_vector(0.0, num_mix_comp)) : 
            stan::math::eval(
              blrm_mix_lupmf_comp(g, num_groups, obs_gidx, r, n, X_comp,
                finite_cov, X_inter, beta, mix_idx_beta, eta, mix_idx_eta,
                pstream__))),
            stan::model::rvalue(mix_log_weight, "mix_log_weight",
              stan::model::index_uni(g))), "assigning variable mix_ll");
        double log_norm = std::numeric_limits<double>::quiet_NaN();
        current_statement__ = 52;
        log_norm = stan::math::log_sum_exp(mix_ll);
        current_statement__ = 53;
        stan::math::validate_non_negative_index("log_EX_prob_mix",
          "num_mix_comp", num_mix_comp);
        Eigen::Matrix<double,-1,1> log_EX_prob_mix =
          Eigen::Matrix<double,-1,1>::Constant(num_mix_comp,
            std::numeric_limits<double>::quiet_NaN());
        current_statement__ = 54;
        stan::model::assign(log_EX_prob_mix,
          stan::math::subtract(mix_ll, log_norm),
          "assigning variable log_EX_prob_mix");
        int mix_config_ind = std::numeric_limits<int>::min();
        current_statement__ = 55;
        mix_config_ind = stan::math::categorical_rng(
                           stan::math::exp(log_EX_prob_mix), base_rng__);
        current_statement__ = 56;
        stan::math::validate_non_negative_index("mix_beta_config",
          "num_comp", num_comp);
        std::vector<int> mix_beta_config =
          std::vector<int>(num_comp, std::numeric_limits<int>::min());
        current_statement__ = 57;
        stan::model::assign(mix_beta_config,
          stan::model::rvalue(mix_idx_beta, "mix_idx_beta",
            stan::model::index_uni(mix_config_ind)),
          "assigning variable mix_beta_config");
        current_statement__ = 58;
        stan::math::validate_non_negative_index("mix_eta_config",
          "num_inter", num_inter);
        std::vector<int> mix_eta_config =
          std::vector<int>(num_inter, std::numeric_limits<int>::min());
        current_statement__ = 59;
        stan::model::assign(mix_eta_config,
          stan::model::rvalue(mix_idx_eta, "mix_idx_eta",
            stan::model::index_uni(mix_config_ind)),
          "assigning variable mix_eta_config");
        current_statement__ = 60;
        stan::model::assign(log_lik_group, (log_norm +
          stan::model::rvalue(log_normfactor_group, "log_normfactor_group",
            stan::model::index_uni(g))), "assigning variable log_lik_group",
          stan::model::index_uni(g));
        {
          int i = std::numeric_limits<int>::min();
          current_statement__ = 61;
          i = 1;
          current_statement__ = 70;
          for (int j = 1; j <= num_comp; ++j) {
            current_statement__ = 67;
            if (stan::model::rvalue(prior_is_EXNEX_comp,
                  "prior_is_EXNEX_comp", stan::model::index_uni(j))) {
              current_statement__ = 64;
              stan::model::assign(beta_EX_prob,
                stan::math::exp(
                  stan::math::log_sum_exp(
                    stan::model::rvalue(log_EX_prob_mix, "log_EX_prob_mix",
                      stan::model::index_multi(
                        stan::model::rvalue(mix_is_EX_beta, "mix_is_EX_beta",
                          stan::model::index_uni(i)))))),
                "assigning variable beta_EX_prob", stan::model::index_uni(g),
                stan::model::index_uni(j));
              current_statement__ = 65;
              i = (i + 1);
            } else {
              current_statement__ = 62;
              stan::model::assign(beta_EX_prob, 1.0,
                "assigning variable beta_EX_prob", stan::model::index_uni(g),
                stan::model::index_uni(j));
            }
            current_statement__ = 68;
            stan::model::assign(beta_group,
              stan::model::rvalue(beta, "beta",
                stan::model::index_uni((g +
                  (stan::math::logical_eq(
                     stan::model::rvalue(mix_beta_config, "mix_beta_config",
                       stan::model::index_uni(j)), 1) ? 0 : num_groups))),
                stan::model::index_uni(j)), "assigning variable beta_group",
              stan::model::index_uni(g), stan::model::index_uni(j));
          }
        }
        {
          int i = std::numeric_limits<int>::min();
          current_statement__ = 72;
          i = 1;
          current_statement__ = 81;
          for (int j = 1; j <= num_inter; ++j) {
            current_statement__ = 78;
            if (stan::model::rvalue(prior_is_EXNEX_inter,
                  "prior_is_EXNEX_inter", stan::model::index_uni(j))) {
              current_statement__ = 75;
              stan::model::assign(eta_EX_prob,
                stan::math::exp(
                  stan::math::log_sum_exp(
                    stan::model::rvalue(log_EX_prob_mix, "log_EX_prob_mix",
                      stan::model::index_multi(
                        stan::model::rvalue(mix_is_EX_eta, "mix_is_EX_eta",
                          stan::model::index_uni(i)))))),
                "assigning variable eta_EX_prob", stan::model::index_uni(g),
                stan::model::index_uni(j));
              current_statement__ = 76;
              i = (i + 1);
            } else {
              current_statement__ = 73;
              stan::model::assign(eta_EX_prob, 1.0,
                "assigning variable eta_EX_prob", stan::model::index_uni(g),
                stan::model::index_uni(j));
            }
            current_statement__ = 79;
            stan::model::assign(eta_group,
              stan::model::rvalue(eta, "eta",
                stan::model::index_uni((g +
                  (stan::math::logical_eq(
                     stan::model::rvalue(mix_eta_config, "mix_eta_config",
                       stan::model::index_uni(j)), 1) ? 0 : num_groups))),
                stan::model::index_uni(j)), "assigning variable eta_group",
              stan::model::index_uni(g), stan::model::index_uni(j));
          }
        }
      }
      out__.write(beta_EX_prob);
      out__.write(eta_EX_prob);
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_groups; ++sym3__) {
            out__.write(beta_group[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          out__.write(eta_group[(sym2__ - 1)][(sym1__ - 1)]);
        }
      }
      out__.write(log_lik_group);
      out__.write(rho_log_beta);
      out__.write(Sigma_corr_eta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>
        log_beta_raw =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(log_beta_raw_1dim__,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__)));
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 1;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 1;
          for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
            current_statement__ = 1;
            stan::model::assign(log_beta_raw, in__.read<local_scalar_t__>(),
              "assigning variable log_beta_raw",
              stan::model::index_uni(sym3__), stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write(log_beta_raw);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> eta_raw =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(eta_raw_1dim__,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
            DUMMY_VAR__));
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        current_statement__ = 2;
        for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
          current_statement__ = 2;
          stan::model::assign(eta_raw, in__.read<local_scalar_t__>(),
            "assigning variable eta_raw", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(eta_raw);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> mu_log_beta =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 3;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 3;
          stan::model::assign(mu_log_beta, in__.read<local_scalar_t__>(),
            "assigning variable mu_log_beta", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write(mu_log_beta);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>
        tau_log_beta_raw =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_strata,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__)));
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 4;
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          current_statement__ = 4;
          for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
            current_statement__ = 4;
            stan::model::assign(tau_log_beta_raw,
              in__.read<local_scalar_t__>(),
              "assigning variable tau_log_beta_raw",
              stan::model::index_uni(sym3__), stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_lb(0, tau_log_beta_raw);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> L_corr_log_beta =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(num_comp,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 5;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 5;
          for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
            current_statement__ = 5;
            stan::model::assign(L_corr_log_beta,
              in__.read<local_scalar_t__>(),
              "assigning variable L_corr_log_beta",
              stan::model::index_uni(sym3__), stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
          }
        }
      }
      out__.write_free_cholesky_factor_corr(L_corr_log_beta);
      Eigen::Matrix<local_scalar_t__,-1,1> mu_eta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
          DUMMY_VAR__);
      current_statement__ = 6;
      stan::model::assign(mu_eta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(num_inter),
        "assigning variable mu_eta");
      out__.write(mu_eta);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tau_eta_raw =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_strata,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
            DUMMY_VAR__));
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        current_statement__ = 7;
        for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
          current_statement__ = 7;
          stan::model::assign(tau_eta_raw, in__.read<local_scalar_t__>(),
            "assigning variable tau_eta_raw", stan::model::index_uni(sym2__),
            stan::model::index_uni(sym1__));
        }
      }
      out__.write_free_lb(0, tau_eta_raw);
      Eigen::Matrix<local_scalar_t__,-1,-1> L_corr_eta =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(num_inter, num_inter,
          DUMMY_VAR__);
      current_statement__ = 8;
      stan::model::assign(L_corr_eta,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(num_inter,
          num_inter), "assigning variable L_corr_eta");
      out__.write_free_cholesky_factor_corr(L_corr_eta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "log_beta_raw",
        "double",
        std::vector<size_t>{static_cast<size_t>(log_beta_raw_1dim__),
          static_cast<size_t>(num_comp), static_cast<size_t>(2)});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "eta_raw",
        "double",
        std::vector<size_t>{static_cast<size_t>(eta_raw_1dim__),
          static_cast<size_t>(num_inter)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "mu_log_beta",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(2)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "tau_log_beta_raw",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(num_comp), static_cast<size_t>(2)});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "L_corr_log_beta",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_comp),
          static_cast<size_t>(2), static_cast<size_t>(2)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "mu_eta", "double",
        std::vector<size_t>{static_cast<size_t>(num_inter)});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "tau_eta_raw",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_strata),
          static_cast<size_t>(num_inter)});
      current_statement__ = 8;
      context__.validate_dims("parameter initialization", "L_corr_eta",
        "double",
        std::vector<size_t>{static_cast<size_t>(num_inter),
          static_cast<size_t>(num_inter)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>
        log_beta_raw =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(log_beta_raw_1dim__,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> log_beta_raw_flat__;
        current_statement__ = 1;
        log_beta_raw_flat__ = context__.vals_r("log_beta_raw");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 1;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 1;
            for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
              current_statement__ = 1;
              stan::model::assign(log_beta_raw, log_beta_raw_flat__[(pos__ -
                1)], "assigning variable log_beta_raw",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 1;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write(log_beta_raw);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> eta_raw =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(eta_raw_1dim__,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
            DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> eta_raw_flat__;
        current_statement__ = 2;
        eta_raw_flat__ = context__.vals_r("eta_raw");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 2;
          for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
            current_statement__ = 2;
            stan::model::assign(eta_raw, eta_raw_flat__[(pos__ - 1)],
              "assigning variable eta_raw", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 2;
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(eta_raw);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> mu_log_beta =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> mu_log_beta_flat__;
        current_statement__ = 3;
        mu_log_beta_flat__ = context__.vals_r("mu_log_beta");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 3;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 3;
            stan::model::assign(mu_log_beta, mu_log_beta_flat__[(pos__ - 1)],
              "assigning variable mu_log_beta",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 3;
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write(mu_log_beta);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>
        tau_log_beta_raw =
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>>(num_strata,
          std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_comp,
            Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__)));
      {
        std::vector<local_scalar_t__> tau_log_beta_raw_flat__;
        current_statement__ = 4;
        tau_log_beta_raw_flat__ = context__.vals_r("tau_log_beta_raw");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 4;
          for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
            current_statement__ = 4;
            for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
              current_statement__ = 4;
              stan::model::assign(tau_log_beta_raw,
                tau_log_beta_raw_flat__[(pos__ - 1)],
                "assigning variable tau_log_beta_raw",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 4;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_lb(0, tau_log_beta_raw);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>> L_corr_log_beta =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,-1>>(num_comp,
          Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(2, 2, DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> L_corr_log_beta_flat__;
        current_statement__ = 5;
        L_corr_log_beta_flat__ = context__.vals_r("L_corr_log_beta");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 5;
          for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
            current_statement__ = 5;
            for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
              current_statement__ = 5;
              stan::model::assign(L_corr_log_beta,
                L_corr_log_beta_flat__[(pos__ - 1)],
                "assigning variable L_corr_log_beta",
                stan::model::index_uni(sym3__),
                stan::model::index_uni(sym2__),
                stan::model::index_uni(sym1__));
              current_statement__ = 5;
              pos__ = (pos__ + 1);
            }
          }
        }
      }
      out__.write_free_cholesky_factor_corr(L_corr_log_beta);
      Eigen::Matrix<local_scalar_t__,-1,1> mu_eta =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> mu_eta_flat__;
        current_statement__ = 6;
        mu_eta_flat__ = context__.vals_r("mu_eta");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 6;
          stan::model::assign(mu_eta, mu_eta_flat__[(pos__ - 1)],
            "assigning variable mu_eta", stan::model::index_uni(sym1__));
          current_statement__ = 6;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(mu_eta);
      std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> tau_eta_raw =
        std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(num_strata,
          Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_inter,
            DUMMY_VAR__));
      {
        std::vector<local_scalar_t__> tau_eta_raw_flat__;
        current_statement__ = 7;
        tau_eta_raw_flat__ = context__.vals_r("tau_eta_raw");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 7;
          for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
            current_statement__ = 7;
            stan::model::assign(tau_eta_raw, tau_eta_raw_flat__[(pos__ - 1)],
              "assigning variable tau_eta_raw",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 7;
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_lb(0, tau_eta_raw);
      Eigen::Matrix<local_scalar_t__,-1,-1> L_corr_eta =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(num_inter, num_inter,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> L_corr_eta_flat__;
        current_statement__ = 8;
        L_corr_eta_flat__ = context__.vals_r("L_corr_eta");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
          current_statement__ = 8;
          for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
            current_statement__ = 8;
            stan::model::assign(L_corr_eta, L_corr_eta_flat__[(pos__ - 1)],
              "assigning variable L_corr_eta",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 8;
            pos__ = (pos__ + 1);
          }
        }
      }
      out__.write_free_cholesky_factor_corr(L_corr_eta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"log_beta_raw", "eta_raw",
                "mu_log_beta", "tau_log_beta_raw", "L_corr_log_beta",
                "mu_eta", "tau_eta_raw", "L_corr_eta"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"beta", "eta", "tau_log_beta", "tau_eta"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"beta_EX_prob", "eta_EX_prob", "beta_group", "eta_group",
             "log_lik_group", "rho_log_beta", "Sigma_corr_eta"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
                                                                    size_t>(
                                                                    log_beta_raw_1dim__),
                                                 static_cast<size_t>(num_comp),
                                                 static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(eta_raw_1dim__),
                  static_cast<size_t>(num_inter)},
                std::vector<size_t>{static_cast<size_t>(num_comp),
                  static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(num_strata),
                  static_cast<size_t>(num_comp), static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(num_comp),
                  static_cast<size_t>(2), static_cast<size_t>(2)},
                std::vector<size_t>{static_cast<size_t>(num_inter)},
                std::vector<size_t>{static_cast<size_t>(num_strata),
                  static_cast<size_t>(num_inter)},
                std::vector<size_t>{static_cast<size_t>(num_inter),
                  static_cast<size_t>(num_inter)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(beta_1dim__),
               static_cast<size_t>(num_comp), static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(eta_1dim__),
               static_cast<size_t>(num_inter)},
             std::vector<size_t>{static_cast<size_t>(num_strata),
               static_cast<size_t>(num_comp), static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(num_strata),
               static_cast<size_t>(num_inter)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(num_groups),
               static_cast<size_t>(num_comp)},
             std::vector<size_t>{static_cast<size_t>(num_groups),
               static_cast<size_t>(num_inter)},
             std::vector<size_t>{static_cast<size_t>(num_groups),
               static_cast<size_t>(num_comp), static_cast<size_t>(2)},
             std::vector<size_t>{static_cast<size_t>(num_groups),
               static_cast<size_t>(num_inter)},
             std::vector<size_t>{static_cast<size_t>(num_groups)},
             std::vector<size_t>{static_cast<size_t>(num_comp)},
             std::vector<size_t>{static_cast<size_t>(num_inter),
               static_cast<size_t>(num_inter)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
          param_names__.emplace_back(std::string() + "log_beta_raw" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
        param_names__.emplace_back(std::string() + "eta_raw" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
        param_names__.emplace_back(std::string() + "mu_log_beta" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
          param_names__.emplace_back(std::string() + "tau_log_beta_raw" + '.'
            + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= num_comp; ++sym3__) {
          param_names__.emplace_back(std::string() + "L_corr_log_beta" + '.'
            + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      param_names__.emplace_back(std::string() + "mu_eta" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
        param_names__.emplace_back(std::string() + "tau_eta_raw" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
        param_names__.emplace_back(std::string() + "L_corr_eta" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= beta_1dim__; ++sym3__) {
            param_names__.emplace_back(std::string() + "beta" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= eta_1dim__; ++sym2__) {
          param_names__.emplace_back(std::string() + "eta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
            param_names__.emplace_back(std::string() + "tau_log_beta" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
          param_names__.emplace_back(std::string() + "tau_eta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          param_names__.emplace_back(std::string() + "beta_EX_prob" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          param_names__.emplace_back(std::string() + "eta_EX_prob" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_groups; ++sym3__) {
            param_names__.emplace_back(std::string() + "beta_group" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          param_names__.emplace_back(std::string() + "eta_group" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        param_names__.emplace_back(std::string() + "log_lik_group" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        param_names__.emplace_back(std::string() + "rho_log_beta" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          param_names__.emplace_back(std::string() + "Sigma_corr_eta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= log_beta_raw_1dim__; ++sym3__) {
          param_names__.emplace_back(std::string() + "log_beta_raw" + '.' +
            std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= eta_raw_1dim__; ++sym2__) {
        param_names__.emplace_back(std::string() + "eta_raw" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
        param_names__.emplace_back(std::string() + "mu_log_beta" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
        for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
          param_names__.emplace_back(std::string() + "tau_log_beta_raw" + '.'
            + std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
            std::to_string(sym1__));
        }
      }
    }
    for (int sym1__ = 1; sym1__ <= ((2 * (2 - 1)) / 2); ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
        param_names__.emplace_back(std::string() + "L_corr_log_beta" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      param_names__.emplace_back(std::string() + "mu_eta" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
      for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
        param_names__.emplace_back(std::string() + "tau_eta_raw" + '.' +
          std::to_string(sym2__) + '.' + std::to_string(sym1__));
      }
    }
    for (int sym1__ = 1; sym1__ <= ((num_inter * (num_inter - 1)) /
         2); ++sym1__) {
      param_names__.emplace_back(std::string() + "L_corr_eta" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= beta_1dim__; ++sym3__) {
            param_names__.emplace_back(std::string() + "beta" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= eta_1dim__; ++sym2__) {
          param_names__.emplace_back(std::string() + "eta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_strata; ++sym3__) {
            param_names__.emplace_back(std::string() + "tau_log_beta" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_strata; ++sym2__) {
          param_names__.emplace_back(std::string() + "tau_eta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          param_names__.emplace_back(std::string() + "beta_EX_prob" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          param_names__.emplace_back(std::string() + "eta_EX_prob" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_comp; ++sym2__) {
          for (int sym3__ = 1; sym3__ <= num_groups; ++sym3__) {
            param_names__.emplace_back(std::string() + "beta_group" + '.' +
              std::to_string(sym3__) + '.' + std::to_string(sym2__) + '.' +
              std::to_string(sym1__));
          }
        }
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_groups; ++sym2__) {
          param_names__.emplace_back(std::string() + "eta_group" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= num_groups; ++sym1__) {
        param_names__.emplace_back(std::string() + "log_lik_group" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= num_comp; ++sym1__) {
        param_names__.emplace_back(std::string() + "rho_log_beta" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= num_inter; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= num_inter; ++sym2__) {
          param_names__.emplace_back(std::string() + "Sigma_corr_eta" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"log_beta_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(log_beta_raw_1dim__) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"parameters\"},{\"name\":\"eta_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(eta_raw_1dim__) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"parameters\"},{\"name\":\"mu_log_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"tau_log_beta_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_strata) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"parameters\"},{\"name\":\"L_corr_log_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(2) + ",\"cols\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"mu_eta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "},\"block\":\"parameters\"},{\"name\":\"tau_eta_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_strata) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"parameters\"},{\"name\":\"L_corr_eta\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(num_inter) + ",\"cols\":" + std::to_string(num_inter) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(beta_1dim__) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"eta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(eta_1dim__) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tau_log_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_strata) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tau_eta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_strata) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"beta_EX_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(num_groups) + ",\"cols\":" + std::to_string(num_comp) + "},\"block\":\"generated_quantities\"},{\"name\":\"eta_EX_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(num_groups) + ",\"cols\":" + std::to_string(num_inter) + "},\"block\":\"generated_quantities\"},{\"name\":\"beta_group\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_groups) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"generated_quantities\"},{\"name\":\"eta_group\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_groups) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_group\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_groups) + "},\"block\":\"generated_quantities\"},{\"name\":\"rho_log_beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_comp) + "},\"block\":\"generated_quantities\"},{\"name\":\"Sigma_corr_eta\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(num_inter) + ",\"cols\":" + std::to_string(num_inter) + "},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"log_beta_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(log_beta_raw_1dim__) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"parameters\"},{\"name\":\"eta_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(eta_raw_1dim__) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"parameters\"},{\"name\":\"mu_log_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"tau_log_beta_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_strata) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"parameters\"},{\"name\":\"L_corr_log_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(((2 * (2 - 1)) /2)) + "}},\"block\":\"parameters\"},{\"name\":\"mu_eta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "},\"block\":\"parameters\"},{\"name\":\"tau_eta_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_strata) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"parameters\"},{\"name\":\"L_corr_eta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(((num_inter * (num_inter - 1)) /2)) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(beta_1dim__) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"eta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(eta_1dim__) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"tau_log_beta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_strata) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"transformed_parameters\"},{\"name\":\"tau_eta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_strata) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"transformed_parameters\"},{\"name\":\"beta_EX_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(num_groups) + ",\"cols\":" + std::to_string(num_comp) + "},\"block\":\"generated_quantities\"},{\"name\":\"eta_EX_prob\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(num_groups) + ",\"cols\":" + std::to_string(num_inter) + "},\"block\":\"generated_quantities\"},{\"name\":\"beta_group\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_groups) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(num_comp) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}}},\"block\":\"generated_quantities\"},{\"name\":\"eta_group\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(num_groups) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_inter) + "}},\"block\":\"generated_quantities\"},{\"name\":\"log_lik_group\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_groups) + "},\"block\":\"generated_quantities\"},{\"name\":\"rho_log_beta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(num_comp) + "},\"block\":\"generated_quantities\"},{\"name\":\"Sigma_corr_eta\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(num_inter) + ",\"cols\":" + std::to_string(num_inter) + "},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((log_beta_raw_1dim__ * num_comp) * 2)
      + (eta_raw_1dim__ * num_inter)) + (num_comp * 2)) + ((num_strata *
      num_comp) * 2)) + ((num_comp * 2) * 2)) + num_inter) + (num_strata *
      num_inter)) + (num_inter * num_inter));
    const size_t num_transformed = emit_transformed_parameters *
      ((((((beta_1dim__ * num_comp) * 2) + (eta_1dim__ * num_inter)) +
      ((num_strata * num_comp) * 2)) + (num_strata * num_inter)));
    const size_t num_gen_quantities = emit_generated_quantities *
      ((((((((num_groups * num_comp) + (num_groups * num_inter)) +
      ((num_groups * num_comp) * 2)) + (num_groups * num_inter)) +
      num_groups) + num_comp) + (num_inter * num_inter)));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = (((((((((log_beta_raw_1dim__ * num_comp) * 2)
      + (eta_raw_1dim__ * num_inter)) + (num_comp * 2)) + ((num_strata *
      num_comp) * 2)) + ((num_comp * 2) * 2)) + num_inter) + (num_strata *
      num_inter)) + (num_inter * num_inter));
    const size_t num_transformed = emit_transformed_parameters *
      ((((((beta_1dim__ * num_comp) * 2) + (eta_1dim__ * num_inter)) +
      ((num_strata * num_comp) * 2)) + (num_strata * num_inter)));
    const size_t num_gen_quantities = emit_generated_quantities *
      ((((((((num_groups * num_comp) + (num_groups * num_inter)) +
      ((num_groups * num_comp) * 2)) + (num_groups * num_inter)) +
      num_groups) + num_comp) + (num_inter * num_inter)));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = model_blrm_exnex_namespace::model_blrm_exnex;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_blrm_exnex_namespace::profiles__;
}
#endif
#endif
